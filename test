//+-------------------------------------------------------------------------------+
//|               Velora/      IVB_Grid_SmartTrailing.mq4                         |
//|               Copyright 2024, Aan Isnaini / aan.isnaini@gmail.com             |
//|                        https://www.mql5.com/en/users/aan.isnaini              |
//+-------------------------------------------------------------------------------+
#define copyrights "Aan Isnaini"
#property copyright copyrights
#property link "aan.isnaini@gmail.com"
#property description "Velora is EA based on Instant Volatility Breakout (IVB), Grid with Smart Trailing Strategy"
#define versionNo "1.0"
#property version versionNo
#property icon "\\Files\\Velora.ico"
#property strict
#include <Arrays\List.mqh>
// Use the ASCII versions (A suffix) with proper types
#import "wininet.dll"
int InternetOpenA(string sAgent, int lAccessType, string sProxyName, string sProxyBypass, int lFlags);
int InternetOpenUrlA(int hInternetSession, string sUrl, string sHeaders, int lHeadersLength, int lFlags, int lContext);
int InternetReadFile(int hFile, uchar &sBuffer[], int lNumBytesToRead, int &lNumberOfBytesRead);
int InternetCloseHandle(int hInet);
#import

// Define constants with proper casting
#define INTERNET_OPEN_TYPE_PRECONFIG 0
#define INTERNET_FLAG_RELOAD 0x80000000
///
#define BOX_PREFIX   "CBreakoutBox_"
#define DCH_PREFIX_H "DC_H_"
#define DCH_PREFIX_L "DC_L_"
#define SL_PREFIX_H  "SL_H_"
#define SL_PREFIX_L  "SL_L_"

// Indicator properties (must be before any functions)
#property indicator_chart_window
#property indicator_buffers 4
#property indicator_color1 Aqua
#property indicator_color2 Red
#property indicator_color3 Yellow
#property indicator_color4 Yellow
#property indicator_width1 17
#property indicator_width2 17
#property indicator_width3 3
#property indicator_width4 3


enum MODE_SYMBOLS
  {
   SYMBOLS_ALL, //All Symbols
   SYMBOLS_THIS //Chart Symbol Only
  };
enum MODE_ORDER_TYPE
  {
   ORDERS_ALL,//Close all order types
   ORDERS_POSITIONS,//Close only open positions
   ORDERS_PENDING//Close only pending orders
  };
MODE_SYMBOLS    Mode_Symbols= SYMBOLS_THIS;//Which Symbol?
MODE_ORDER_TYPE Mode_Orders = ORDERS_ALL;//Which Order Type?


//---- DC ATR Ratio Indicator Parameters
int Period_DC = 28;                 // Donchian Channel Period
int Period_ATR = 30;                // ATR Period for Ratio Calculation
double Alert_Ratio = 3.0;           // DC/ATR Ratio for Alert
bool Alert_Popup = false;           // Enable Popup Alerts
bool Alert_On_Every_Bar = false;    // Alert on Every New Bar
bool Draw_Box = true;               // Draw Alert Boxes
int    MaxBars           = 200;   // Batas max perulangan garis
double StopLevels = 0;
//---- indicator buffers
double dchigh[], dclow[], bxhigh[], bxlow[];
double pmd;
datetime Time_1;

//--- Input Parameters
input double InitialLotSize       = 0.01;    // Starting lot size
input double LotSizeIncrement     = 0.01;    // Fixed lot increment (0=FIXED Lot/No Increment lot)
input double TakeProfits           = 0;     // Take Profit in pips
double TakeProfit           = TakeProfits;     // Take Profit in pips
input double StopLosss             = 0;       // Stop Loss in pips
double StopLoss             = StopLosss;       // Stop Loss in pips

input double FirstGridDistances    = 200;     // pips initial distance
 double FirstGridDistance    = FirstGridDistances;     // pips initial distance
input double GridDistanceMultiplier = 1.5;   // Distance multiplier for next grid
input int    MaxGridOrders        = 33;      // Maximum grid levels
input bool   UseHedging           = false;   // Allow buy and sell grids simultaneously
input int    HedgingDelaySeconds  = 3600;    // Delay before manual buy and sell grids simultaneously (seconds)
input int    MaxHedgingOrders     = 10;      // Max total buy and sell grids simultaneously orders
input int    MaxSpread            = 100;     // Maximum allowed spread
input bool   UseSmartGrid         = false;   // Enable adaptive grid distances based on volatility
input ENUM_TIMEFRAMES ATR_AdaptiveGridDistances_TF = PERIOD_CURRENT;//ATR_AdaptiveGridDistances_TF
input int ATR_AdaptiveGridDistances_Period = 14;//ATR_AdaptiveGridDistances_Period
input int GridUpdateFrequency = 3600; // Update grid distances every X seconds (default: 1 hour)
datetime lastGridUpdateTime = 0;
extern string STrailing="-----  Trailing Setup   -------";//-----  Trailing Setup   -------
input double TrailingSteps         = 30;      // Trailing stop distance (pips)
 double TrailingStep         = TrailingSteps;      // Trailing stop distance (pips)
input bool   UseATRTrailing       = true;    // Use ATR-based trailing stop
input ENUM_TIMEFRAMES ATR_Trailing_TF = PERIOD_CURRENT; // ATR Timeframe for Trailing
input int    ATR_Trailing_Period = 10;      // ATR period for Trailing
input double ATRTrailingMultiplier = 2.5;    // ATR multiplier for trailing
input double    BufferPIPs            = 150;     // Buffer pip to add BEP
 double    BufferPIP            = BufferPIPs;     // Buffer pip to add BEP
input bool   UseTrailingTP        = true;    // Enable trailing Take Profit (default false)
input double MinProfitForTrailings = 100.0;   // Minimum profit in pips to start trailing (default 50)
double MinProfitForTrailing = MinProfitForTrailings;   // Minimum profit in pips to start trailing (default 50)
input double TrailingTPSteps       = 50.0;    //Trail TPStep in pips (def:50, applies if UseTrailingTP=true)
 double TrailingTPStep       = TrailingTPSteps;    //Trail TPStep in pips(def:50, applies if UseTrailingTP=true)
input bool UseDynamicTPAndPartialClose = true;  // Use Dynamic TP And Partial Close
input double PartialProfitLevels   = 200.0;   // Profit level in pips to take partial profit
 double PartialProfitLevel   = PartialProfitLevels;   // Profit level in pips to take partial profit
input double PartialClosePercent  = 30.0;    // Percentage of lot size to close for partial profit
input ENUM_TIMEFRAMES ATR_UpdateDynamicTPAndPartialClose_TF = PERIOD_CURRENT;
input int ATR_UpdateDynamicTPAndPartialClose_Period = 10;
input double DynamicTPMultiplier  = 1.5;     // Multiplier for dynamic TP based on ATR
input double MomentumROCThreshold = 0.5;     // ROC threshold for momentum trigger 
extern string eSTrailing="-----  End Of Trailing Setup   -------";//-----  End Of Trailing Setup   -------


extern string Sindicator="-----  Entry Indicators Setup   -------";//-----  Entry Indicators Setup   -------
input ENUM_TIMEFRAMES Keltner_TF = PERIOD_CURRENT;//Keltner Timeframe
input double Keltner_ATR_Multiplier = 1.5;   // Multiplier for Keltner bands (BTC 1.2)
input int ATR_Keltner_Period = 10; //ATR Keltner Period
input int    Keltner_EMA_Period   = 8;       // EMA period for Keltner
input ENUM_TIMEFRAMES ATR_Current_TF = PERIOD_CURRENT;//ATR_Current_TF
input int ATR_Current_Period = 10;//ATR_Current_Period
input ENUM_TIMEFRAMES ATR_Average_TF = PERIOD_CURRENT;//ATR_Average_TF
input int ATR_Average_Period = 10;//ATR_Average_Period
input ENUM_TIMEFRAMES Volume_Current_TF = PERIOD_CURRENT;//Volume_Current_TF
input ENUM_TIMEFRAMES Volume_Average_TF = PERIOD_CURRENT;//Volume_Average_TF
input int    ROC_Period           = 3;       // Rate of Change period
input double ROC_Threshold        = 0.2;     // ROC threshold percentage (BTC 0.3)
input double Volume_Multiplier    = 1.0;     // Volume multiplier (BTC 1.3)

input bool   UseRangingMarketFilter = true;  // Use Ranging Market Filter
input int MinBarRangingMarket = 369;//Min Bar Ranging Market
input ENUM_TIMEFRAMES smaRangingMarketTF = PERIOD_CURRENT;//SMA Ranging Market Timeframe
input int smaRangingMarketPeriod = 100;//SMA Ranging Market Period
input double RangingThreshold     = 0.02;    // Threshold Ranging Market (Optimize: 0.003â€“0.01)
input ENUM_TIMEFRAMES ATRRangingMarketTF = PERIOD_CURRENT;//ATR Ranging Market Timeframe
input int ATRRangingMarketPeriod = 10;//ATR RangingMarket Period
input double MaxATR               = 2.5;     // ATR threshold RangingMarket in USD
input bool   UseADXFilter         = false;   // Use ADX filter to avoid trending markets
input ENUM_TIMEFRAMES ADXFilterTF = PERIOD_CURRENT;// ADX Timeframe
input int    ADX_Period           = 14;      // ADX period
input double ADX_Threshold        = 25.0;    // ADX threshold to detect trending market
extern string eSindicator="-----  End of Entry Indicators Setup   -------";//-----  End of Entry Indicators Setup   -------
extern string edd="-----  Drawdown Manager   -------";//-----  Drawdown Manager   -------
input double MaxDrawdown          = 100.0;   // Max drawdown percentage
extern string eother="-----  Other   -------";//-----  Other   -------

input bool    Debug               = false;   // Debug
input int       MagicNumber = 12345;//Magic Number
string trade_comment = WindowExpertName()+"(V"+versionNo +")"; // Order comment
int Errors;
bool FIFO=true;
// Fibonacci Indicator Settings
string   inpName           = "Aan_Fibo";      // Fibo Name
int      inpDepth          = 12;             // ZigZag Depth
int      inpDeviation      = 5;              // ZigZag Deviation
int      inpBackStep       = 3;              // ZigZag BackStep
int      inpLeg            = 1;              // ZigZag Leg
color    inpLineColor      = clrRed;         // Line Color
color    inpLevelsColor    = clrAqua;        // Levels Color
bool     inpRay            = false;          // Ray
double   inpLevel1         = 0.0;            // Level 1
double   inpLevel2         = 23.6;           // Level 2
double   inpLevel3         = 38.2;           // Level 3
double   inpLevel4         = 50.0;           // Level 4
double   inpLevel5         = 61.8;           // Level 5
double   inpLevel6         = 100.0;          // Level 6
double   inpLevel7         = 161.8;          // Level 7
double   inpLevel8         = 261.8;          // Level 8
double   inpLevel9         = 423.6;          // Level 9
int  SubWindow = 0;
int Corner = 0;//Button Position
int Move_X = 0;// X Move
int Move_Y = 0;//Y Move
int Button_Width = 125;//Button Width
string Font_Type = "Arial Bold";//Button Font
color Font_Color = clrWhite;//Button Font Color
int Font_Size = 8;//Button Font Size
//--- Structures
struct KeltnerValues {
   double upper;
   double middle;
   double lower;
};

struct ROCValue {
   double value;
};

struct TradeInfo {
   int    ticket;
   int    type;
   double openPrice;
   double lotSize;
   double stopLoss;
   double takeProfit;
   datetime openTime;
   string comment;
};

//--- Global Variables
TradeInfo TradesArray[];
double    GridDistances[];
double    LotSizes[];
int       CurrentGridLevelBuy = 0;  // Grid level for buy orders
int       CurrentGridLevelSell = 0; // Grid level for sell orders
double    BEP_Price = 0.0;
bool      IsTrailingActive = false;
datetime  LastTradeTime = 0;
int       LastError = 0;

//+------------------------------------------------------------------+
//| Get ZigZag values for Fibonacci                                  |
//+------------------------------------------------------------------+
bool GetZZ(datetime &time[], double &price[])
{
   bool ret = false;
   int leg = (int)MathMax(1, inpLeg);
   int cnt = 0;
   int idx = 0;
   double zz = 0.0;

   for(int i = 0; i < Bars - 1; i++)
   {
      zz = iCustom(_Symbol, 0, "ZigZag", inpDepth, inpDeviation, inpBackStep, 0, i);
      if(zz <= 0.0 || zz == EMPTY_VALUE || zz > 1000000.0) continue;
      cnt++;
      if(cnt < leg) continue;
      time[idx] = Time[i];
      price[idx] = zz;
      idx++;
      if(idx > 1) { ret = true; break; }
   }
   return ret;
}

//+------------------------------------------------------------------+
//| Draw Fibonacci Retracement                                       |
//+------------------------------------------------------------------+
bool FiboDraw(const string name, datetime &time[], double &price[], const color clrFibo = clrRed, const color clrLevels = clrYellow)
{
   long chart_ID = 0;
   int sub_window = 0;
   ResetLastError();

   if(!ObjectCreate(chart_ID, name, OBJ_FIBO, sub_window, time[1], price[1], time[0], price[0]))
   {
      Print(__FUNCTION__, ": failed to create Fibonacci Retracement! Error code = ", GetLastError());
      return(false);
   }

   ObjectSetInteger(chart_ID, name, OBJPROP_COLOR, clrFibo);
   ObjectSetInteger(chart_ID, name, OBJPROP_STYLE, STYLE_SOLID);
   ObjectSetInteger(chart_ID, name, OBJPROP_WIDTH, 1);
   ObjectSetInteger(chart_ID, name, OBJPROP_BACK, false);
   ObjectSetInteger(chart_ID, name, OBJPROP_SELECTABLE, false);
   ObjectSetInteger(chart_ID, name, OBJPROP_SELECTED, false);
   ObjectSetInteger(chart_ID, name, OBJPROP_RAY_RIGHT, inpRay);
   ObjectSetInteger(chart_ID, name, OBJPROP_HIDDEN, false);
   ObjectSetInteger(chart_ID, name, OBJPROP_ZORDER, 0);

   FiboSetLevels(name, price, clrLevels);
   return(true);
}

//+------------------------------------------------------------------+
//| Set Fibonacci Levels                                             |
//+------------------------------------------------------------------+
bool FiboSetLevels(const string name, double &price[], const color clrLevels = clrYellow)
{
   double levels[9];
   levels[0] = inpLevel1; 
   levels[1] = inpLevel2;
   levels[2] = inpLevel3;
   levels[3] = inpLevel4;
   levels[4] = inpLevel5;
   levels[5] = inpLevel6;
   levels[6] = inpLevel7;
   levels[7] = inpLevel8;
   levels[8] = inpLevel9;
   long chart_ID = 0;
   int N = ArraySize(levels);
   string str = "";

   ResetLastError();
   ObjectSetInteger(chart_ID, name, OBJPROP_LEVELS, N);

   for(int i = 0; i < N; i++)
   {
      ObjectSetDouble(chart_ID, name, OBJPROP_LEVELVALUE, i, levels[i]/100.0);
      ObjectSetInteger(chart_ID, name, OBJPROP_LEVELCOLOR, i, clrLevels);
      ObjectSetInteger(chart_ID, name, OBJPROP_LEVELSTYLE, i, STYLE_DOT);
      ObjectSetInteger(chart_ID, name, OBJPROP_LEVELWIDTH, i, 1);
      
      str = DoubleToString(levels[i],1) + "% = ";
      str += DoubleToString(price[0]+(levels[i]/100.0)*(price[1]-price[0]), _Digits) + "  ";
      ObjectSetString(chart_ID, name, OBJPROP_LEVELTEXT, i, str);
   }
   return(true);
}

//+------------------------------------------------------------------+
//| Update Fibonacci                                                 |
//+------------------------------------------------------------------+
void UpdateFibonacci()
{
   datetime times[2];
   double price[2];

   if(!GetZZ(times, price)) return;

   if(ObjectFind(0, inpName) < 0) 
      FiboDraw(inpName, times, price, inpLineColor, inpLevelsColor);
   else
   {
      ObjectMove(0, inpName, 0, times[1], price[1]);
      ObjectMove(0, inpName, 1, times[0], price[0]);
      FiboSetLevels(inpName, price, inpLevelsColor);
   }
   ChartRedraw();
}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
//#resource "\\Indicators\\sb.ex4"
int OnInit()
{
  // int handle = iCustom(_Symbol, _Period, "::Indicators\\sb.ex4", 0,0);
   // if(handle == INVALID_HANDLE) {
    //    Print("Gagal memuat indikator!");
        //return(INIT_FAILED);
  //  }
  MakeLogo();
   if(boolRestrictOnInit())
      return(INIT_FAILED);
    StopLevels = MarketInfo(Symbol(), MODE_STOPLEVEL);
   ArrayResize(GridDistances, MaxGridOrders);
   ArrayResize(LotSizes, MaxGridOrders);
   // Convert pips to points based on symbol's digits
    TakeProfit = TakeProfits * GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    StopLoss = StopLosss *  GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    FirstGridDistance = FirstGridDistances *  GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    TrailingStep = TrailingSteps *  GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    BufferPIP = BufferPIPs *  GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    PartialProfitLevel = PartialProfitLevels *  GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    TrailingTPStep = TrailingTPSteps *  GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    MinProfitForTrailing = MinProfitForTrailings *  GetPengaliX();//(digits == 3 || digits == 5 ? 10 * point : point);
    
   // Initialize DC ATR Ratio Indicator
   SetIndexShift(0, 0);
   SetIndexShift(1, 0);
   SetIndexShift(2, 0); 
   SetIndexShift(3, 0);
   SetIndexDrawBegin(0, Period_DC);
   SetIndexDrawBegin(1, Period_DC);
   SetIndexDrawBegin(2, Period_DC);
   SetIndexDrawBegin(3, Period_DC);
   //InitDCATRRatio();
   ObjectsDeleteAll(0, BOX_PREFIX);
   ObjectsDeleteAll(0, DCH_PREFIX_H);
   ObjectsDeleteAll(0, DCH_PREFIX_L);
   ObjectsDeleteAll(0, SL_PREFIX_H);
   ObjectsDeleteAll(0, SL_PREFIX_L);
   // Initialize grid distances based on smart grid setting
   if(UseSmartGrid)
      CalculateAdaptiveGridDistances();
   else
   {
      GridDistances[0] = FirstGridDistance;
      for(int i = 1; i < MaxGridOrders; i++)
         GridDistances[i] = GridDistances[i-1] * GridDistanceMultiplier;
   }
   
   // Initialize lot sizes
   double lot = InitialLotSize;
   double volumeMin=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN);
   if(InitialLotSize < volumeMin)lot =volumeMin;
   double LotSizeIncrements = LotSizeIncrement;
   if(LotSizeIncrement >0)
   {      
      double volumeStep=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_STEP);
      if(LotSizeIncrements < volumeStep)LotSizeIncrements =volumeStep;
      double VolumeUpperLimit = (double)0.0;
      lot = AlignLots(Symbol(), lot, 0, VolumeUpperLimit);
      LotSizeIncrements = AlignLots(Symbol(), LotSizeIncrements, 0, VolumeUpperLimit);
   }
   LotSizes[0] = lot;
   for(int i = 1; i < MaxGridOrders; i++)
      LotSizes[i] = LotSizes[i-1] + LotSizeIncrements;
   
   ReadOpenTrades();
   InitializeVisuals();
   SetupChart();
   if(GlobalVariableCheck("IVB_TrailingActive"))
      IsTrailingActive = GlobalVariableGet("IVB_TrailingActive") > 0;
   Pekali = GetPengali();
   CreateButtons();
      ToolTips_Text("CloseALL_Symbol_btn");
      ToolTips_Text("CloseALL_btn");
      ToolTips_Text("CloseALL_Buy_btn");
      ToolTips_Text("CloseALL_Sell_btn");
      ToolTips_Text("CloseALL_Profit_btn");
      ToolTips_Text("CloseALL_Loss_btn");
      ToolTips_Text("OPEN_BUY_btn");
      ToolTips_Text("OPEN_SELL_btn");
      ToolTips_Text("Delete___btn");
      ToolTips_Text("ChangeBE_btn");
      ToolTips_Text("SLplusOnebtn");
      ToolTips_Text("DeleteSL_btn");
      ToolTips_Text("ChangeSL_btn");
      ToolTips_Text("ChangeTP_btn");
      //direct buy
      ObjectCreate("LOT_OP_BUY", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("LOT_OP_BUY", OBJPROP_CORNER, Corner);
      ObjectSet("LOT_OP_BUY", OBJPROP_XSIZE, Button_Width -70);
      ObjectSet("LOT_OP_BUY", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("LOT_OP_BUY", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_OP_BUY", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_OP_BUY", OBJPROP_YDISTANCE, 95 + Move_Y);
      ObjectSet("LOT_OP_BUY", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("LOT_OP_BUY", OBJPROP_COLOR, clrBlue);
      ObjectSetText("LOT_OP_BUY", DoubleToStr(InitialLotSize, 2), 13, Font_Type, Font_Color);
      //direct sell
      ObjectCreate("LOT_OP_SELL", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("LOT_OP_SELL", OBJPROP_CORNER, Corner);
      ObjectSet("LOT_OP_SELL", OBJPROP_XSIZE, Button_Width -70);
      ObjectSet("LOT_OP_SELL", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("LOT_OP_SELL", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_OP_SELL", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_OP_SELL", OBJPROP_YDISTANCE, 130 + Move_Y);
      ObjectSet("LOT_OP_SELL", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("LOT_OP_SELL", OBJPROP_COLOR, clrRed);
      ObjectSetText("LOT_OP_SELL", DoubleToStr(InitialLotSize, 2), 13, Font_Type, Font_Color);
      ///stop
      ///stop
      ObjectCreate("LOT_BUY", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("LOT_BUY", OBJPROP_CORNER, Corner);
      ObjectSet("LOT_BUY", OBJPROP_XSIZE, Button_Width -70);
      ObjectSet("LOT_BUY", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("LOT_BUY", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_BUY", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_BUY", OBJPROP_YDISTANCE, 170 + Move_Y);
      ObjectSet("LOT_BUY", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("LOT_BUY", OBJPROP_COLOR, clrBlue);
      ObjectSetText("LOT_BUY", DoubleToStr(InitialLotSize, 2), 13, Font_Type, Font_Color);
      ObjectCreate("PRICE_BUY", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("PRICE_BUY", OBJPROP_CORNER, Corner);
      ObjectSet("PRICE_BUY", OBJPROP_XSIZE, Button_Width -50);
      ObjectSet("PRICE_BUY", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("PRICE_BUY", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_BUY", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_BUY", OBJPROP_YDISTANCE, 170 + Move_Y);
      ObjectSet("PRICE_BUY", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("PRICE_BUY", OBJPROP_COLOR, clrBlue);
      ObjectSetText("PRICE_BUY", DoubleToStr(Ask, Digits), 13, Font_Type, Font_Color);
      ObjectCreate("LOT_SELL", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("LOT_SELL", OBJPROP_CORNER, Corner);
      ObjectSet("LOT_SELL", OBJPROP_XSIZE, Button_Width -70);
      ObjectSet("LOT_SELL", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("LOT_SELL", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_SELL", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_SELL", OBJPROP_YDISTANCE, 200 + Move_Y);
      ObjectSet("LOT_SELL", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("LOT_SELL", OBJPROP_COLOR, clrRed);
      ObjectSetText("LOT_SELL", DoubleToStr(InitialLotSize, 2), 13, Font_Type, Font_Color);
      ObjectCreate("PRICE_SELL", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("PRICE_SELL", OBJPROP_CORNER, Corner);
      ObjectSet("PRICE_SELL", OBJPROP_XSIZE, Button_Width -50);
      ObjectSet("PRICE_SELL", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("PRICE_SELL", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_SELL", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_SELL", OBJPROP_YDISTANCE, 200 + Move_Y);
      ObjectSet("PRICE_SELL", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("PRICE_SELL", OBJPROP_COLOR, clrRed);
      ObjectSetText("PRICE_SELL", DoubleToStr(Bid, Digits), 13, Font_Type, Font_Color);
      ///stop
      ///Limit
      ObjectCreate("LOT_BUY_LIMIT", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_CORNER, Corner);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_XSIZE, Button_Width -70);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_YDISTANCE, 025 + Move_Y);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("LOT_BUY_LIMIT", OBJPROP_COLOR, clrBlue);
      ObjectSetText("LOT_BUY_LIMIT", DoubleToStr(InitialLotSize, 2), 13, Font_Type, Font_Color);
      ObjectCreate("PRICE_BUY_LIMIT", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_CORNER, Corner);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_XSIZE, Button_Width -50);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_YDISTANCE, 025 + Move_Y);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("PRICE_BUY_LIMIT", OBJPROP_COLOR, clrBlue);
      ObjectSetText("PRICE_BUY_LIMIT", DoubleToStr(Ask, Digits), 13, Font_Type, Font_Color);
      ObjectCreate("LOT_SELL_LIMIT", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_CORNER, Corner);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_XSIZE, Button_Width -70);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_XDISTANCE, 140 + Move_X);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_YDISTANCE, 055 + Move_Y);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("LOT_SELL_LIMIT", OBJPROP_COLOR, clrRed);
      ObjectSetText("LOT_SELL_LIMIT", DoubleToStr(InitialLotSize, 2), 13, Font_Type, Font_Color);
      ObjectCreate("PRICE_SELL_LIMIT", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_CORNER, Corner);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_XSIZE, Button_Width -50);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_XDISTANCE, 200 + Move_X);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_YDISTANCE, 055 + Move_Y);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("PRICE_SELL_LIMIT", OBJPROP_COLOR, clrRed);
      ObjectSetText("PRICE_SELL_LIMIT", DoubleToStr(Bid, Digits), 13, Font_Type, Font_Color);
      ///Limit
      ObjectCreate("TP_Edit", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("TP_Edit", OBJPROP_CORNER, Corner);
      ObjectSet("TP_Edit", OBJPROP_XSIZE, Button_Width + 020);
      ObjectSet("TP_Edit", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("TP_Edit", OBJPROP_XDISTANCE, 880 + Move_X);
      ObjectSet("TP_Edit", OBJPROP_YDISTANCE, 025 + Move_Y);
      ObjectSet("TP_Edit", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("TP_Edit", OBJPROP_COLOR, clrDarkGreen);
      ObjectSetText("TP_Edit", DoubleToStr(Bid, Digits), 13, Font_Type, Font_Color);
      ObjectCreate("SL_Edit", OBJ_EDIT, SubWindow, 0, 0);
      ObjectSet("SL_Edit", OBJPROP_CORNER, Corner);
      ObjectSet("SL_Edit", OBJPROP_XSIZE, Button_Width + 020);
      ObjectSet("SL_Edit", OBJPROP_YSIZE, Font_Size*2.8);
      ObjectSet("SL_Edit", OBJPROP_XDISTANCE, 880 + Move_X);
      //ObjectSet("SL_Edit", OBJPROP_XDISTANCE, 860 + Move_X);
      ObjectSet("SL_Edit", OBJPROP_YDISTANCE, 055 + Move_Y);
      ObjectSet("SL_Edit", OBJPROP_ALIGN, ALIGN_CENTER);
      ObjectSet("SL_Edit", OBJPROP_COLOR, clrDeepPink);
      ObjectSetText("SL_Edit", DoubleToStr(Bid, Digits), 13, Font_Type, Font_Color);
   
   if(Debug) Print("EA Initialized with Grid Trading System, Hedging: ", UseHedging, 
         ", Smart Grid: ", UseSmartGrid, ", ATR Trailing: ", UseATRTrailing, 
         ", ADX Filter: ", UseADXFilter, ", IsTrailingActive: ", IsTrailingActive);
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Calculate Adaptive Grid Distances                               |
//+------------------------------------------------------------------+
void CalculateAdaptiveGridDistances()
{
    double atr = iATR(Symbol(), ATR_AdaptiveGridDistances_TF, ATR_AdaptiveGridDistances_Period, 0);
    if(atr == 0) 
    {
        if(Debug) Print("ATR returned 0, using default grid distances");
        return;
    }
    
    double baseDistance = atr / Point * 2.0; // 2x ATR as base distance
    
    // Preserve minimum distance
    if(baseDistance < FirstGridDistance * 0.5) 
        baseDistance = FirstGridDistance * 0.5;
    if(baseDistance > FirstGridDistance * 2.0) 
        baseDistance = FirstGridDistance * 2.0;
    
    GridDistances[0] = baseDistance;
    for(int i = 1; i < MaxGridOrders; i++)
    {
        GridDistances[i] = GridDistances[i-1] * (1.0 + (GridDistanceMultiplier-1.0) * (1.0 - i/MaxGridOrders));
        
        // Additional safety checks
        if(GridDistances[i] < GridDistances[i-1] * 0.8)
            GridDistances[i] = GridDistances[i-1] * 0.8;
        if(GridDistances[i] > GridDistances[i-1] * 2.0)
            GridDistances[i] = GridDistances[i-1] * 2.0;
    }
    
    if(Debug)
    {
        string distances = "";
        for(int i = 0; i < MathMin(5, MaxGridOrders); i++)
            distances += StringFormat("%.1f, ", GridDistances[i]);
        Print("Updated Grid Distances: ", distances, "... (Based on ATR: ", atr, ")");
    }
}

//+------------------------------------------------------------------+
//| Cached Message Fetcher with Fallback                            |
//+------------------------------------------------------------------+
string GetDailyMessage()
{
    static string cachedMessage = "";
    static datetime lastFetchTime = 0;
    
    // Refresh cache every hour or if empty
    if(TimeCurrent() - lastFetchTime > 3600 || StringLen(cachedMessage) == 0)
    {
        string newMessage = FetchURLContent("https://www.myblog.com/info.txt");
        if(StringLen(newMessage) > 0)
        {
            cachedMessage = newMessage;
            lastFetchTime = TimeCurrent();
            if(Debug) Print("Fetched new message from URL: ", cachedMessage);
        }
        else if(StringLen(cachedMessage) == 0)
        {
            cachedMessage = "Have a nice day"; // Fallback
            if(Debug) Print("Using fallback message");
        }
    }
    return cachedMessage;
}

//+------------------------------------------------------------------+
//| Fetch Content from URL                                          |
//+------------------------------------------------------------------+
string FetchURLContent(string url)
{
   string result = "";
   int hInternet = InternetOpenA("MT4/1.0", INTERNET_OPEN_TYPE_PRECONFIG, "0", "0", 0);
   
   if(hInternet <= 0)
   {
      if(Debug) Print("InternetOpenA failed. Error: ", GetLastError());
      return result;
   }
   
   int hUrl = InternetOpenUrlA(
      hInternet, 
      url, 
      "0", 
      0, 
      (int)INTERNET_FLAG_RELOAD, 
      0
   );
   
   if(hUrl <= 0)
   {
      if(Debug) Print("InternetOpenUrlA failed for URL: ", url, " Error: ", GetLastError());
      InternetCloseHandle(hInternet);
      return result;
   }
   
   uchar buffer[1024];
   int bytesRead = 0;
   
   while(InternetReadFile(hUrl, buffer, ArraySize(buffer), bytesRead) && bytesRead > 0)
   {
      result += CharArrayToString(buffer, 0, bytesRead);
   }
   
   InternetCloseHandle(hUrl);
   InternetCloseHandle(hInternet);
   
   StringReplace(result, "\r", "");
   StringReplace(result, "\n", "");
   
   return result;
}

//+------------------------------------------------------------------+
//| Calculate Trade Statistics                                      |
//+------------------------------------------------------------------+
void CalculateTradeStats(double &totalLots, double &moneyProfit, double &pipProfit, string &orderComments)
{
    totalLots = 0;
    moneyProfit = 0;
    pipProfit = 0;
    orderComments = "";
    
    for(int i = 0; i < ArraySize(TradesArray); i++)
    {
        if(OrderSelect(TradesArray[i].ticket, SELECT_BY_TICKET, MODE_TRADES))
        {
            totalLots += TradesArray[i].lotSize;
            double currentPrice = TradesArray[i].type == OP_BUY ? Bid : Ask;
            double pipDiff = (currentPrice - BEP_Price) / Point;
            if(TradesArray[i].type == OP_SELL) pipDiff = -pipDiff;
            
            pipProfit += pipDiff * TradesArray[i].lotSize;
            moneyProfit += OrderProfit() + OrderSwap() + OrderCommission();
            orderComments += TradesArray[i].comment + (i < ArraySize(TradesArray)-1 ? ", " : "");
        }
    }
}

//+------------------------------------------------------------------+
//| Validate Order Before Sending                                   |
//+------------------------------------------------------------------+
bool ValidateOrder(int cmd, double price, double lot, double sl, double tp)
{
    // Check spread
    double currentSpread = (double)MarketInfo(Symbol(), MODE_SPREAD);
    if(currentSpread > MaxSpread)
    {
        if(Debug) Print("Spread too high: ", currentSpread, " > ", MaxSpread);
        return false;
    }
    
    // Check stop levels
    double stopLevel = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
    
    if(cmd == OP_BUY)
    {
        if(sl > 0 && sl >= price - stopLevel)
        {
            if(Debug) Print("SL too close for BUY order. SL:", sl, " Price:", price, " StopLevel:", stopLevel);
            return false;
        }
        if(tp > 0 && tp <= price + stopLevel)
        {
            if(Debug) Print("TP too close for BUY order. TP:", tp, " Price:", price, " StopLevel:", stopLevel);
            return false;
        }
    }
    else // OP_SELL
    {
        if(sl > 0 && sl <= price + stopLevel)
        {
            if(Debug) Print("SL too close for SELL order. SL:", sl, " Price:", price, " StopLevel:", stopLevel);
            return false;
        }
        if(tp > 0 && tp >= price - stopLevel)
        {
            if(Debug) Print("TP too close for SELL order. TP:", tp, " Price:", price, " StopLevel:", stopLevel);
            return false;
        }
    }
    
    // Check margin requirements
    if(AccountFreeMarginCheck(Symbol(), cmd, lot) <= 0)
    {
        if(Debug) Print("Insufficient margin for ", EnumToString((ENUM_ORDER_TYPE)cmd), " order of ", lot, " lots");
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| Read open trades into array with grid integrity check            |
//+------------------------------------------------------------------+
void ReadOpenTrades()
{
   ArrayFree(TradesArray);
   int total = OrdersTotal();
   ArrayResize(TradesArray, total);
   CurrentGridLevelBuy = 0;
   CurrentGridLevelSell = 0;
   
   int index = 0;
   for(int i = 0; i < total; i++)
   {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && OrderMagicNumber() == MagicNumber)
      {
         string comment = OrderComment();
         if(StringFind(comment, UseHedging ? trade_comment+"-" : trade_comment+"-[") != 0)
         {
            if(Debug) Print("Warning: Order #", OrderTicket(), " has invalid comment: ", comment);
         }
         TradesArray[index].ticket = OrderTicket();
         TradesArray[index].type = OrderType();
         TradesArray[index].openPrice = OrderOpenPrice();
         TradesArray[index].lotSize = OrderLots();
         TradesArray[index].stopLoss = OrderStopLoss();
         TradesArray[index].takeProfit = OrderTakeProfit();
         TradesArray[index].openTime = OrderOpenTime();
         TradesArray[index].comment = comment;
         index++;
         if(OrderType() == OP_BUY) CurrentGridLevelBuy++;
         else if(OrderType() == OP_SELL) CurrentGridLevelSell++;
      }
   }
   ArrayResize(TradesArray, index);
   
   if(!VerifyGridIntegrity())
   {
      if(Debug) Print("Grid integrity check failed. Consider resetting or reviewing open trades.");
   }
}

//+------------------------------------------------------------------+
//| Verify grid integrity                                           |
//+------------------------------------------------------------------+
bool VerifyGridIntegrity()
{
   if(ArraySize(TradesArray) <= 1) return true;
   
   TradeInfo buyTrades[];
   TradeInfo sellTrades[];
   ArrayResize(buyTrades, CurrentGridLevelBuy);
   ArrayResize(sellTrades, CurrentGridLevelSell);
   int buyIndex = 0, sellIndex = 0;
   
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      if(TradesArray[i].type == OP_BUY)
         buyTrades[buyIndex++] = TradesArray[i];
      else if(TradesArray[i].type == OP_SELL)
         sellTrades[sellIndex++] = TradesArray[i];
   }
   
   for(int i = 0; i < ArraySize(buyTrades)-1; i++)
   {
      for(int j = i+1; j < ArraySize(buyTrades); j++)
      {
         if(buyTrades[i].openTime > buyTrades[j].openTime)
         {
            TradeInfo temp = buyTrades[i];
            buyTrades[i] = buyTrades[j];
            buyTrades[j] = temp;
         }
      }
   }
   for(int i = 0; i < ArraySize(sellTrades)-1; i++)
   {
      for(int j = i+1; j < ArraySize(sellTrades); j++)
      {
         if(sellTrades[i].openTime > sellTrades[j].openTime)
         {
            TradeInfo temp = sellTrades[i];
            sellTrades[i] = sellTrades[j];
            sellTrades[j] = temp;
         }
      }
   }
   
   if(CurrentGridLevelBuy > 1)
   {
      for(int i = 1; i < ArraySize(buyTrades); i++)
      {
         double distance = (buyTrades[i-1].openPrice - buyTrades[i].openPrice) / Point;
         double expectedDistance = GridDistances[i-1];
         if(MathAbs(distance - expectedDistance) > 1.0)
         {
            if(Debug) Print("Buy grid integrity failed at index ", i, ": Expected distance ", expectedDistance, ", Actual: ", distance);
            return false;
         }
         string expectedComment = UseHedging ? StringFormat(trade_comment+"-Buy-[%d]", i+1) : StringFormat(trade_comment+"-[%d]", i+1);
         if(buyTrades[i].comment != expectedComment)
         {
            if(Debug) Print("Buy grid integrity failed at index ", i, ": Expected comment ", expectedComment, ", Actual: ", buyTrades[i].comment);
            return false;
         }
      }
   }
   
   if(CurrentGridLevelSell > 1)
   {
      for(int i = 1; i < ArraySize(sellTrades); i++)
      {
         double distance = (sellTrades[i].openPrice - sellTrades[i-1].openPrice) / Point;
         double expectedDistance = GridDistances[i-1];
         if(MathAbs(distance - expectedDistance) > 1.0)
         {
            if(Debug) Print("Sell grid integrity failed at index ", i, ": Expected distance ", expectedDistance, ", Actual: ", distance);
            return false;
         }
         string expectedComment = UseHedging ? StringFormat(trade_comment+"-Sell-[%d]", i+1) : StringFormat(trade_comment+"-[%d]", i+1);
         if(sellTrades[i].comment != expectedComment)
         {
            if(Debug) Print("Sell grid integrity failed at index ", i, ": Expected comment ", expectedComment, ", Actual: ", sellTrades[i].comment);
            return false;
         }
      }
   }
   
   if(!UseHedging && CurrentGridLevelBuy > 0 && CurrentGridLevelSell > 0)
   {
      if(Debug) Print("Grid integrity failed: Mixed buy/sell orders detected when hedging is disabled.");
      return false;
   }
   
   return true;
}

//+------------------------------------------------------------------+
//| Get SL and TP from first trade                                  |
//+------------------------------------------------------------------+
void GetFirstTradeSLTP(int orderType, double &sl, double &tp)
{
   sl = 0.0;
   tp = 0.0;
   datetime earliestTime = TimeCurrent();
   int firstTradeIndex = -1;
   
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      if(TradesArray[i].type == orderType && TradesArray[i].openTime < earliestTime)
      {
         earliestTime = TradesArray[i].openTime;
         firstTradeIndex = i;
      }
   }
   
   if(firstTradeIndex >= 0)
   {
      sl = TradesArray[firstTradeIndex].stopLoss;
      tp = TradesArray[firstTradeIndex].takeProfit;
   }
}

//+------------------------------------------------------------------+
//| Reset grid when all orders closed                               |
//+------------------------------------------------------------------+
void ResetGrid()
{
   if(OrdersTotal() == 0)
   {
      CurrentGridLevelBuy = 0;
      CurrentGridLevelSell = 0;
      IsTrailingActive = false;
      GlobalVariableSet("IVB_TrailingActive", 0);
      ArrayFree(TradesArray);
      BEP_Price = 0.0;
   }
}

//+------------------------------------------------------------------+
//| Expert tick function                                            |
//+------------------------------------------------------------------+
void OnTick()
{
    if(boolRestrictOnTick())
           return;
   if(!IsConnected())
   {
      if(Debug) Print("No internet connection. Skipping tick.");
      return;
   }
   // Update grid distances if using smart grid and time has elapsed
    if(UseSmartGrid && TimeCurrent() - lastGridUpdateTime >= GridUpdateFrequency)
    {
        CalculateAdaptiveGridDistances();
        lastGridUpdateTime = TimeCurrent();
        if(Debug) Print("Updated adaptive grid distances at ", TimeToString(TimeCurrent()));
    }
   ResetGrid();
   
   if(TimeCurrent() - LastTradeTime < 1) return;
   LastTradeTime = TimeCurrent();
   
   ReadOpenTrades();
   UpdateIndicators();
   
   if(IsMaxDrawdownHit()) 
   {
      CloseAllTrades();
      return;
   }
   
   bool RangingMarketFilter = true;
   if(UseRangingMarketFilter) 
      RangingMarketFilter = IsRangingMarket();
   
   if((CurrentGridLevelBuy == 0 && CurrentGridLevelSell == 0) && RangingMarketFilter)
   {
      if(CheckBuySignal())  OpenTrade(OP_BUY);
      if(CheckSellSignal()) OpenTrade(OP_SELL);
   }
   else
   {
      CheckGridConditions();
   }
   
   if(UseHedging && ArraySize(TradesArray) > 0)
   {
      double totalProfit = CalculateTotalProfit();
      if(CurrentGridLevelBuy > 0 && CurrentGridLevelSell == 0 && CurrentGridLevelBuy < MaxGridOrders - 1 && 
         TimeCurrent() - TradesArray[0].openTime > HedgingDelaySeconds && totalProfit > 0)
      {
         OpenTrade(OP_SELL);
      }
      if(CurrentGridLevelSell > 0 && CurrentGridLevelBuy == 0 && CurrentGridLevelSell < MaxGridOrders - 1 && 
         TimeCurrent() - TradesArray[0].openTime > HedgingDelaySeconds && totalProfit > 0)
      {
         OpenTrade(OP_BUY);
      }
   }
   
   if(ArraySize(TradesArray) > 0 && ArraySize(TradesArray) <= MaxHedgingOrders) 
   {
      UpdateBreakEvenSL();
      UpdateSmartTrailing();
      if(UseDynamicTPAndPartialClose)
      {
         UpdateDynamicTPAndPartialClose();
         UpdateAdaptiveTrailingTP();
      }
   }
   if((!(MQLInfoInteger(MQL_OPTIMIZATION) || (MQLInfoInteger(MQL_TESTER) && !MQLInfoInteger(MQL_VISUAL_MODE)))))
   {
      UpdateFibonacci(); // Update Fibonacci levels on each tick
      DisplayDashboard();
      //////
      static datetime lastBarTime = 0;
      if (Time[1] == lastBarTime) return;
      lastBarTime = Time[1];   
      if (Draw_Box)
         DrawVisuals();
         /////
   }
}

//+------------------------------------------------------------------+
//| Fixed Grid Conditions Check                                     |
//+------------------------------------------------------------------+
void CheckGridConditions()
{
   if(CurrentGridLevelBuy >= MaxGridOrders && CurrentGridLevelSell >= MaxGridOrders) 
   {
      return;
   }
   
   int buyOrders = CountOrders(OP_BUY);
   int sellOrders = CountOrders(OP_SELL);
   
   if(buyOrders > 0 && CurrentGridLevelBuy < MaxGridOrders)
   {
      double lastBuyPrice = GetLastOrderPrice(OP_BUY);
      if(lastBuyPrice == 0) return;
      
      double currentDistance = (lastBuyPrice - Bid) / Point;
      
      if(CurrentGridLevelBuy > 0 && CurrentGridLevelBuy < ArraySize(GridDistances))
      {
         if(currentDistance >= GridDistances[CurrentGridLevelBuy-1])
         {
            OpenTrade(OP_BUY);
         }
      }
   }
   
   if(sellOrders > 0 && CurrentGridLevelSell < MaxGridOrders)
   {
      double lastSellPrice = GetLastOrderPrice(OP_SELL);
      if(lastSellPrice == 0) return;
      
      double currentDistance = (Ask - lastSellPrice) / Point;
      
      if(CurrentGridLevelSell > 0 && CurrentGridLevelSell < ArraySize(GridDistances))
      {
         if(currentDistance >= GridDistances[CurrentGridLevelSell-1])
         {
            OpenTrade(OP_SELL);
         }
      }
   }
}
//+------------------------------------------------------------------+
//| Check the correctness of the order volume                        |
//+------------------------------------------------------------------+
bool CheckVolumeValue(double volume,string &description)
  {
//--- minimal allowed volume for trade operations
   double min_volume=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MIN);
   if(volume<min_volume)
     {
      description=StringFormat("Volume is less than the minimal allowed SYMBOL_VOLUME_MIN=%.2f",min_volume);
      return(false);
     }

//--- maximal allowed volume of trade operations
   double max_volume=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_MAX);
   if(volume>max_volume)
     {
      description=StringFormat("Volume is greater than the maximal allowed SYMBOL_VOLUME_MAX=%.2f",max_volume);
      return(false);
     }

//--- get minimal step of volume changing
   double volume_step=SymbolInfoDouble(Symbol(),SYMBOL_VOLUME_STEP);

   int ratio=(int)MathRound(volume/volume_step);
   if(MathAbs(ratio*volume_step-volume)>0.0000001)
     {
      description=StringFormat("Volume is not a multiple of the minimal step SYMBOL_VOLUME_STEP=%.2f, the closest correct volume is %.2f",
                               volume_step,ratio*volume_step);
      return(false);
     }
   description="Correct volume value";
   return(true);
  }
  double AlignLots(string symbol, double lots, double lowerlots = 0.0, double upperlots = 0.0)
  {
   double LotStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);
   double LotSize = SymbolInfoDouble(symbol, SYMBOL_TRADE_CONTRACT_SIZE);
   double MinLots = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
   double MaxLots = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
   if(LotStep > MinLots)
      MinLots = LotStep;
   if(lots == EMPTY_VALUE)
     {
      lots = 0.0;
     }
   lots = MathRound(lots / LotStep) * LotStep;
   if(lots < MinLots)
     {
      lots = MinLots;
     }
   if(lots > MaxLots)
     {
      lots = MaxLots;
     }
   if(lowerlots > 0.0)
     {
      lowerlots = MathRound(lowerlots / LotStep) * LotStep;
      if(lots < lowerlots)
        {
         lots = lowerlots;
        }
     }
   if(upperlots > 0.0)
     {
      upperlots = MathRound(upperlots / LotStep) * LotStep;
      if(lots > upperlots)
        {
         lots = upperlots;
        }
     }
   return lots;
  }
 double NormalizeVolume(const double volume,string symbol=NULL)
  {
   if(symbol==NULL || symbol=="") symbol=_Symbol;
   double volumeStep=SymbolInfoDouble(symbol,SYMBOL_VOLUME_STEP);
   double volumeMin=SymbolInfoDouble(symbol,SYMBOL_VOLUME_MIN);
   double volumeMax=SymbolInfoDouble(symbol,SYMBOL_VOLUME_MAX);
   double volumeNormalized=int(volume/volumeStep)*volumeStep;
   return(volumeNormalized<volumeMin?0.0:(volumeNormalized>volumeMax?volumeMax:volumeNormalized));
  }
//+------------------------------------------------------------------+
//| Trade Execution with Lot Size Control                            |
//+------------------------------------------------------------------+
void OpenTrade(int cmd)
{
   if(!IsTradeAllowed())
   {
      if(Debug) Print("Trading not allowed - Check AutoTrading button");
      return;
   }
   
   double lot = LotSizes[0];
   int gridLevel = (cmd == OP_BUY) ? CurrentGridLevelBuy : CurrentGridLevelSell;
   if(gridLevel >= 0 && gridLevel < ArraySize(LotSizes))
   {
      lot = LotSizes[gridLevel];
   }
   //string desc = Symbol();
  // if(CheckVolumeValue(lot,Symbol())==false) return;
   //if(!CheckVolumeValue(lot,desc))
 //  {
  //    return;
 //  }
   double price = (cmd == OP_BUY) ? Ask : Bid;
   double sl = 0.0, tp = 0.0;
   double StopLevel = MarketInfo(Symbol(), MODE_STOPLEVEL);
   if(gridLevel == 0)
   {
      if(cmd == OP_BUY)
      {
         RefreshRates();
         if(price - Ask < StopLevel * _Point)
            price = Ask + StopLevel * _Point;
         price = NormalizeDouble(Ask, Digits);
            
         //sl = StopLoss > 0 ? price - StopLoss * Point : 0.0;
         //tp = TakeProfit > 0 ? price + TakeProfit * Point : 0.0;
          sl = StopLoss > 0 ? NormalizeDouble(Ask - StopLoss * Point, Digits) : 0.0;
         tp = TakeProfit > 0 ? NormalizeDouble(Ask + TakeProfit * Point, Digits) : 0.0;
      }
      else
      {
          RefreshRates();
         if(Bid - price < StopLevel * _Point)
            price = Bid - StopLevel * _Point;
         price = NormalizeDouble(Bid, Digits);     
         //sl = StopLoss > 0 ? price + StopLoss * Point : 0.0;
         //tp = TakeProfit > 0 ? price - TakeProfit * Point : 0.0;
         sl = StopLoss > 0 ? NormalizeDouble(Bid  + StopLoss * Point, Digits) : 0.0;
         tp = TakeProfit > 0 ? NormalizeDouble(Bid - TakeProfit * Point, Digits) : 0.0;
         //Take = IIFd(TP == 0, 0, NormalizeDouble(Bid - TP * Point, Digits));
         //Stop = IIFd(SL == 0, 0, NormalizeDouble(Bid + SL * Point, Digits));
      }
   }
   else
   {
      GetFirstTradeSLTP(cmd, sl, tp);
   }
   
   // Use enhanced order validation
   if(!ValidateOrder(cmd, price, lot, sl, tp))
      return;
   
   sl = NormalizeDouble(sl, Digits);
   tp = NormalizeDouble(tp, Digits);
   
   string comment = UseHedging ? StringFormat(trade_comment+"-%s-[%d]", cmd == OP_BUY ? "Buy" : "Sell", gridLevel+1) 
                              : StringFormat(trade_comment+"-[%d]", gridLevel+1);
  // price = NormalizeDouble(price, Digits);
   int ticket = OrderSend(Symbol(), cmd, lot, price, 3, sl, tp, comment, MagicNumber, 0, clrNONE);
   
   if(ticket > 0)
   {
      if(cmd == OP_BUY) CurrentGridLevelBuy++;
      else CurrentGridLevelSell++;
      
      if(Debug) Print("Order opened: ", EnumToString((ENUM_ORDER_TYPE)cmd),
            " Lot:", lot, " Price:", price, " SL:", sl, " TP:", tp, 
            " GridLevel:", gridLevel+1, " Comment:", comment);
      
      ArrayResize(TradesArray, ArraySize(TradesArray) + 1);
      int index = ArraySize(TradesArray) - 1;
      TradesArray[index].ticket = ticket;
      TradesArray[index].type = cmd;
      TradesArray[index].openPrice = price;
      TradesArray[index].lotSize = lot;
      TradesArray[index].stopLoss = sl;
      TradesArray[index].takeProfit = tp;
      TradesArray[index].openTime = TimeCurrent();
      TradesArray[index].comment = comment;
   }
   else
   {
      LastError = GetLastError();
      if(Debug) Print("OrderSend failed with error #", LastError);
   }
}
void OpenTrade2(int cmd, double lots)
{
   if(!IsTradeAllowed())
   {
      if(Debug) Print("Trading not allowed - Check AutoTrading button");
      return;
   }
   
   double lot = lots;
   int gridLevel = (cmd == OP_BUY) ? CurrentGridLevelBuy : CurrentGridLevelSell;
   //if(gridLevel >= 0 && gridLevel < ArraySize(LotSizes))
   //{
   //   lot = LotSizes[gridLevel];
   //}
   
   double price = (cmd == OP_BUY) ? Ask : Bid;
   double sl = 0.0, tp = 0.0;
   
   if(gridLevel == 0)
   {
      if(cmd == OP_BUY)
      {
         sl = StopLoss > 0 ? price - StopLoss * Point : 0.0;
         tp = TakeProfit > 0 ? price + TakeProfit * Point : 0.0;
      }
      else
      {
         sl = StopLoss > 0 ? price + StopLoss * Point : 0.0;
         tp = TakeProfit > 0 ? price - TakeProfit * Point : 0.0;
      }
   }
   else
   {
      GetFirstTradeSLTP(cmd, sl, tp);
   }
   
   // Use enhanced order validation
   if(!ValidateOrder(cmd, price, lot, sl, tp))
      return;
   
   sl = NormalizeDouble(sl, Digits);
   tp = NormalizeDouble(tp, Digits);
   
   string comment = UseHedging ? StringFormat(trade_comment+"-%s-[%d]", cmd == OP_BUY ? "Buy" : "Sell", gridLevel+1) 
                              : StringFormat(trade_comment+"-[%d]", gridLevel+1);
   
   int ticket = OrderSend(Symbol(), cmd, lot, price, 3, sl, tp, comment, MagicNumber, 0, clrNONE);
    //int ticket = OrderSend(Symbol(), cmd, lot, price, 3, 0, 0, comment, MagicNumber, 0, clrNONE);
   if(ticket > 0)
   {
      if(cmd == OP_BUY) CurrentGridLevelBuy++;
      else CurrentGridLevelSell++;
      
      if(Debug) Print("Order opened: ", EnumToString((ENUM_ORDER_TYPE)cmd),
            " Lot:", lot, " Price:", price, " SL:", sl, " TP:", tp, 
            " GridLevel:", gridLevel+1, " Comment:", comment);
      
      ArrayResize(TradesArray, ArraySize(TradesArray) + 1);
      int index = ArraySize(TradesArray) - 1;
      TradesArray[index].ticket = ticket;
      TradesArray[index].type = cmd;
      TradesArray[index].openPrice = price;
      TradesArray[index].lotSize = lot;
      TradesArray[index].stopLoss = sl;
      TradesArray[index].takeProfit = tp;
      TradesArray[index].openTime = TimeCurrent();
      TradesArray[index].comment = comment;
   }
   else
   {
      LastError = GetLastError();
      if(Debug) Print("OrderSend failed with error #", LastError);
   }
}

//+------------------------------------------------------------------+
//| Display Dashboard Function                                      |
//+------------------------------------------------------------------+
color clrSpreadOK = clrLime;
color clrSpreadBad = clrRed;
color clrSpreadGood = clrLime;

void DisplayDashboard()
{
   // ====== TAMBAHKAN INI DI AWAL FUNGSI ====== //
//    double currentSpread = MarketInfo(Symbol(), MODE_SPREAD);
//    string spreadText = StringFormat("Spread: %.1f/%.1f", currentSpread, MaxSpread);
//    color spreadColor = (currentSpread <= MaxSpread) ? clrSpreadGood : clrSpreadBad;
//    
//    if(ObjectFind("Dash_Spread") < 0)
//    {
//        ObjectCreate(0, "Dash_Spread", OBJ_LABEL, 0, 0, 0);
//        ObjectSetInteger(0, "Dash_Spread", OBJPROP_CORNER, CORNER_LEFT_UPPER);
//        ObjectSetInteger(0, "Dash_Spread", OBJPROP_XDISTANCE, 10);
//        ObjectSetInteger(0, "Dash_Spread", OBJPROP_YDISTANCE, 15);
//    }
//    ObjectSetText("Dash_Spread", spreadText, 9, "Arial", spreadColor);
    int x = 10;
   int y = 235;
   int lineHeight = 18;
   int fontSize = 10;
   int panelWidth = 400;
   color panelColor = C'20,20,30';
   color headerColor = C'65,105,225';
   color profitColor = C'0,200,0';
   color lossColor = C'220,20,60';
   
   int totalLines = 27;
   int panelHeight = 30 + (totalLines * lineHeight);

   // Create main panel
   string dashboardName = "IVB_Dashboard_Main";
   if(ObjectFind(0, dashboardName) < 0)
   {
      ObjectCreate(0, dashboardName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   }
   ObjectSetInteger(0, dashboardName, OBJPROP_XDISTANCE, x-5);
   ObjectSetInteger(0, dashboardName, OBJPROP_YDISTANCE, y-5);
   ObjectSetInteger(0, dashboardName, OBJPROP_XSIZE, panelWidth);
   ObjectSetInteger(0, dashboardName, OBJPROP_YSIZE, panelHeight);
   ObjectSetInteger(0, dashboardName, OBJPROP_BGCOLOR, panelColor);
   ObjectSetInteger(0, dashboardName, OBJPROP_BORDER_TYPE, BORDER_FLAT);
   ObjectSetInteger(0, dashboardName, OBJPROP_BORDER_COLOR, clrGray);
   ObjectSetInteger(0, dashboardName, OBJPROP_CORNER, CORNER_LEFT_UPPER);

   // Shadow effect
   string shadowName = "IVB_Dashboard_Shadow";
   if(ObjectFind(0, shadowName) < 0)
   {
      ObjectCreate(0, shadowName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   }
   ObjectSetInteger(0, shadowName, OBJPROP_XDISTANCE, x-3);
   ObjectSetInteger(0, shadowName, OBJPROP_YDISTANCE, y-3);
   ObjectSetInteger(0, shadowName, OBJPROP_XSIZE, panelWidth);
   ObjectSetInteger(0, shadowName, OBJPROP_YSIZE, panelHeight);
   ObjectSetInteger(0, shadowName, OBJPROP_BGCOLOR, C'0,0,0');
   ObjectSetInteger(0, shadowName, OBJPROP_BORDER_TYPE, BORDER_FLAT);
   ObjectSetInteger(0, shadowName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, shadowName, OBJPROP_ZORDER, 0);

   // ==================== ACCOUNT SUMMARY ====================
   CreateLabel("Header1", "ACCOUNT SUMMARY", x, y, headerColor, fontSize+1, "Arial Bold");
   y += lineHeight;
   
   double balance = AccountBalance();
   double equity = AccountEquity();
   double margin = AccountMargin();
   double marginLevel = (margin > 0) ? (equity / margin) * 100 : 0;
   double riskRatio = (balance > 0) ? (equity/balance)*100 : 0;
   
   CreateLabel("Balance", StringFormat("â€¢ Balance: %s", DoubleToString(balance, 2)), x, y, clrWhite, fontSize, "Arial");
   CreateLabel("Equity", StringFormat("â€¢ Equity: %s (%.1f%%)", DoubleToString(equity, 2), riskRatio), 
             x+150, y, (equity >= balance) ? profitColor : lossColor, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("Margin", StringFormat("â€¢ Margin: %s", DoubleToString(margin, 2)), x, y, clrWhite, fontSize, "Arial");
   CreateLabel("MarginLevel", StringFormat("â€¢ Margin Level: %.1f%%", marginLevel), 
             x+150, y, GetMarginColor(marginLevel), fontSize, "Arial");
   y += lineHeight;

   // ==================== TRADE SUMMARY ====================
   CreateLabel("Header2", "TRADE SUMMARY", x, y, headerColor, fontSize+1, "Arial Bold");
   y += lineHeight;
   
   double totalLots, moneyProfit, pipProfit;
   string orderComments;
   CalculateTradeStats(totalLots, moneyProfit, pipProfit, orderComments);
   
   int buyOrders = CountOrders(OP_BUY);
   int sellOrders = CountOrders(OP_SELL);
   double avgProfitPerLot = (totalLots > 0) ? moneyProfit/totalLots : 0;
   
   CreateLabel("MoneyPL", StringFormat("â€¢ P/L: %s", DoubleToString(moneyProfit, 2)), 
             x, y, (moneyProfit >= 0) ? profitColor : lossColor, fontSize, "Arial");
   CreateLabel("PipPL", StringFormat("â€¢ PIP: %s", DoubleToString(pipProfit,1)), 
             x+150, y, (pipProfit >= 0) ? profitColor : lossColor, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("Lots", StringFormat("â€¢ Lots: %.2f (B:%d/S:%d)", totalLots, buyOrders, sellOrders), 
             x, y, clrWhite, fontSize, "Arial");
   CreateLabel("AvgProfit", StringFormat("â€¢ Avg/Lot: %s", DoubleToString(avgProfitPerLot, 2)), 
             x+150, y, (avgProfitPerLot >= 0) ? profitColor : lossColor, fontSize, "Arial");
   y += lineHeight;

   // ==================== GRID SYSTEM ====================
   CreateLabel("Header3", "GRID SYSTEM", x, y, headerColor, fontSize+1, "Arial Bold");
   y += lineHeight;
   
   double nextGridPriceBuy = 0;
   double nextGridPriceSell = 0;
   double nextLotSize = InitialLotSize;
   int gridOrders = CurrentGridLevelBuy + CurrentGridLevelSell;
   
   if(gridOrders > 0) {
      CalculateBEP();
      if(CurrentGridLevelBuy > 0 && CurrentGridLevelBuy < MaxGridOrders-1)
         nextGridPriceBuy = GetLastOrderPrice(OP_BUY) - GridDistances[CurrentGridLevelBuy] * Point;
      if(CurrentGridLevelSell > 0 && CurrentGridLevelSell < MaxGridOrders-1)
         nextGridPriceSell = GetLastOrderPrice(OP_SELL) + GridDistances[CurrentGridLevelSell] * Point;
      nextLotSize = LotSizes[UseHedging ? MathMax(CurrentGridLevelBuy, CurrentGridLevelSell) : gridOrders];
   }
   
   CreateLabel("GridLevels", StringFormat("â€¢ Levels: %d/%d (B:%d/S:%d)", 
             gridOrders, MaxGridOrders, CurrentGridLevelBuy, CurrentGridLevelSell), 
             x, y, clrWhite, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("NextGrid", StringFormat("â€¢ Next Grid: B:%s / S:%s", 
             (nextGridPriceBuy>0)?DoubleToString(nextGridPriceBuy,Digits):"-",
             (nextGridPriceSell>0)?DoubleToString(nextGridPriceSell,Digits):"-"), 
             x, y, clrWhite, fontSize, "Arial");
   y += lineHeight;
   
   int nextGridIndex = (gridOrders<ArraySize(GridDistances)) ? gridOrders : ArraySize(GridDistances)-1;
   CreateLabel("NextLotDist", StringFormat("â€¢ Next Lot: %.2f | Dist: %d pips", 
             nextLotSize, GridDistances[nextGridIndex]), 
             x, y, clrWhite, fontSize, "Arial");
   y += lineHeight;

   // ==================== MARKET CONDITIONS ====================
   CreateLabel("Header4", "MARKET CONDITIONS", x, y, headerColor, fontSize+1, "Arial Bold");
   y += lineHeight;
   
   double spread = MarketInfo(Symbol(), MODE_SPREAD);
   double atr = iATR(Symbol(), 0, 14, 0);
   long volume = Volume[0];
   bool isRanging = IsRangingMarket();
   
   CreateLabel("Spread", StringFormat("â€¢ Spread: %.1f pips", spread), 
             x, y, (spread > MaxSpread) ? lossColor : clrWhite, fontSize, "Arial");
   CreateLabel("ATR", StringFormat("â€¢ ATR(14): %.4f", atr), 
             x+150, y, clrWhite, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("Volume", StringFormat("â€¢ Volume: %d", volume), x, y, clrWhite, fontSize, "Arial");
   CreateLabel("MarketState", StringFormat("â€¢ Market: %s", isRanging?"Ranging":"Trending"), 
             x+150, y, isRanging?clrYellow:clrOrange, fontSize, "Arial");
   y += lineHeight;

   // ==================== SIGNAL CONDITIONS ====================
   CreateLabel("Header5", "SIGNAL CONDITIONS", x, y, headerColor, fontSize+1, "Arial Bold");
   y += lineHeight;
   
   // BUY Signal
   bool buySignal = CheckBuySignal();
   KeltnerValues keltner = CalculateKeltner(1, Keltner_EMA_Period, Keltner_ATR_Multiplier, ATR_Keltner_Period);
   ROCValue roc = CalculateROC(1, ROC_Period);
   double ATR_Current = iATR(Symbol(), ATR_Current_TF, ATR_Current_Period, 1);
   long Volume_Current = Volume[0];
   
   CreateLabel("BuySignal", StringFormat("BUY: [%s]", buySignal?"ACTIVE":"INACTIVE"), 
             x, y, buySignal?profitColor:clrSilver, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("BuyCond1", StringFormat("  Price > Upper: %s (%.5f > %.5f)", 
             (Close[0]>keltner.upper)?"âœ”":"âœ–", Close[0], keltner.upper), 
             x, y, (Close[0]>keltner.upper)?profitColor:lossColor, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("BuyCond2", StringFormat("  ROC > Thresh: %s (%.2f > %.2f)", 
             (roc.value>ROC_Threshold)?"âœ”":"âœ–", roc.value, ROC_Threshold), 
             x, y, (roc.value>ROC_Threshold)?profitColor:lossColor, fontSize, "Arial");
   y += lineHeight;

   // SELL Signal
   bool sellSignal = CheckSellSignal();
   CreateLabel("SellSignal", StringFormat("SELL: [%s]", sellSignal?"ACTIVE":"INACTIVE"), 
             x, y, sellSignal?lossColor:clrSilver, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("SellCond1", StringFormat("  Price < Lower: %s (%.5f < %.5f)", 
             (Close[0]<keltner.lower)?"âœ”":"âœ–", Close[0], keltner.lower), 
             x, y, (Close[0]<keltner.lower)?lossColor:profitColor, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("SellCond2", StringFormat("  ROC < -Thresh: %s (%.2f < -%.2f)", 
             (roc.value<-ROC_Threshold)?"âœ”":"âœ–", roc.value, ROC_Threshold), 
             x, y, (roc.value<-ROC_Threshold)?lossColor:profitColor, fontSize, "Arial");
   y += lineHeight;

   // Additional common conditions
   double ATR_Average = 0;
   for(int i = 1; i <= 50; i++) 
   {
      ATR_Average += iATR(Symbol(), ATR_Average_TF, ATR_Average_Period, i);
   }
   ATR_Average /= 50.0;
   
   // Fixed volume calculation with proper type handling
   double Volume_Average = 0;
   int barsToCalculate = MathMin(20, Bars);
   for(int i = 1; i <= barsToCalculate; i++) 
   {
      Volume_Average += (double)Volume[i]; // Explicit conversion to double
   }
   Volume_Average /= barsToCalculate;
   
   bool atrSpike = ATR_Current > (ATR_Average * 1.3);
   bool volSpike = (double)Volume_Current > (Volume_Average * Volume_Multiplier);
   
   CreateLabel("CommonCond1", StringFormat("ATR Spike: %s (%.2f > %.2f)", 
             atrSpike?"âœ”":"âœ–", ATR_Current, ATR_Average*1.3), 
             x, y, atrSpike?profitColor:lossColor, fontSize, "Arial");
   y += lineHeight;
   
   CreateLabel("CommonCond2", StringFormat("Volume Spike: %s (%d > %.0f)", 
             volSpike?"âœ”":"âœ–", Volume_Current, Volume_Average*Volume_Multiplier), 
             x, y, volSpike?profitColor:lossColor, fontSize, "Arial");
}

color GetMarginColor(double level)
{
   if(level > 500) return clrLime;
   if(level > 200) return clrYellow;
   if(level > 100) return clrOrangeRed;
   return clrRed;
}

void CreateLabel(string name, string text, int x, int y, color clr, int fontSize, string font="Arial")
{
   string fullName = "IVB_Label_" + name;
   if(ObjectFind(0, fullName) < 0)
   {
      ObjectCreate(0, fullName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, fullName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetString(0, fullName, OBJPROP_FONT, font);
   }
   ObjectSetInteger(0, fullName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, fullName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, fullName, OBJPROP_COLOR, clr);
   ObjectSetInteger(0, fullName, OBJPROP_FONTSIZE, fontSize);
   ObjectSetString(0, fullName, OBJPROP_TEXT, text);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   ObjectsDeleteAll(0, "IVB_");
   ObjectsDeleteAll(0, "Keltner_");
   ObjectsDeleteAll(0, "Dash_Spread");
   ObjectDelete(0, inpName); // Delete Fibonacci object on EA removal
   DeleteButtons();
   //DeleteButton("btnrestAndRealizeHEDGE");
   //DeleteButton("btnrestAndRealizeGRID");
   //DeleteButton("btnNextReversed");
   //DeleteButton("btnTrailSLPIP");
   ObjectDelete("SL_Edit");
   ObjectDelete("TP_Edit");
   ObjectDelete("LOT_BUY");
   ObjectDelete("LOT_SELL");
    ObjectDelete("LOT_OP_BUY");
   ObjectDelete("LOT_OP_SELL");
   ObjectDelete("PRICE_BUY");
   ObjectDelete("PRICE_SELL");
   ObjectDelete("LOT_BUY_LIMIT");
   ObjectDelete("LOT_SELL_LIMIT");
   ObjectDelete("PRICE_BUY_LIMIT");
   ObjectDelete("PRICE_SELL_LIMIT");
   ObjectDelete("g");
   ObjectDelete("B2");
   ObjectsDeleteAll();
   if(Debug) Print("EA Deinitialized");
}

//+------------------------------------------------------------------+
//| Indicator Calculations                                          |
//+------------------------------------------------------------------+
KeltnerValues CalculateKeltner(int shift, int emaPeriod, double atrMultiplier, int atrPeriod)
{
   KeltnerValues result;
   result.middle = iMA(Symbol(), Keltner_TF, emaPeriod, 0, MODE_EMA, PRICE_TYPICAL, shift);
   double atr = iATR(Symbol(), Keltner_TF, atrPeriod, shift);
   result.upper = result.middle + atrMultiplier * atr;
   result.lower = result.middle - atrMultiplier * atr;
   return result;
}

ROCValue CalculateROC(int shift, int period)
{
   ROCValue result;
   if(shift + period < Bars)
      result.value = (Close[shift] - Close[shift + period]) / Close[shift + period] * 100.0;
   else
      result.value = 0;
   return result;
}

//+------------------------------------------------------------------+
//| Signal Checking Functions                                       |
//+------------------------------------------------------------------+

bool CheckBuySignal()
{
   KeltnerValues keltner = CalculateKeltner(1, Keltner_EMA_Period, Keltner_ATR_Multiplier, ATR_Keltner_Period);
   ROCValue roc = CalculateROC(1, ROC_Period);
   double ATR_Current = iATR(Symbol(), ATR_Current_TF, ATR_Current_Period, 1);
   
   double ATR_Average = 0;
   for(int i = 1; i <= 50; i++) ATR_Average += iATR(Symbol(), ATR_Average_TF, ATR_Average_Period, i);
   ATR_Average /= 50.0;
   
   double Volume_Current = (double)iVolume(Symbol(), Volume_Current_TF, 1);
   double Volume_Average = 0;
   for(int i = 1; i <= 20; i++) Volume_Average += (double)iVolume(Symbol(), Volume_Average_TF, i);
   Volume_Average /= 20.0;
   
   int conditionsMet = 0;
   if(Close[0] > keltner.upper) conditionsMet++;
   if(roc.value > ROC_Threshold) conditionsMet++;
   if(ATR_Current > ATR_Average * 1.3) conditionsMet++;
   if(Volume_Current > Volume_Average * Volume_Multiplier) conditionsMet++;
   
   return (conditionsMet >= 3);
}

bool CheckSellSignal()
{
   KeltnerValues keltner = CalculateKeltner(1, Keltner_EMA_Period, Keltner_ATR_Multiplier, ATR_Keltner_Period);
   ROCValue roc = CalculateROC(1, ROC_Period);
   double ATR_Current = iATR(Symbol(), ATR_Current_TF, ATR_Current_Period, 1);
   
   double ATR_Average = 0;
   for(int i = 1; i <= 50; i++) ATR_Average += iATR(Symbol(), ATR_Average_TF, ATR_Average_Period, i);
   ATR_Average /= 50.0;
   
   double Volume_Current = (double)iVolume(Symbol(), Volume_Current_TF, 1);
   double Volume_Average = 0;
   for(int i = 1; i <= 20; i++) Volume_Average += (double)iVolume(Symbol(), Volume_Average_TF, i);
   Volume_Average /= 20.0;
   
   int conditionsMet = 0;
   if(Close[0] < keltner.lower) conditionsMet++;
   if(roc.value < -ROC_Threshold) conditionsMet++;
   if(ATR_Current > ATR_Average * 1.3) conditionsMet++;
   if(Volume_Current > Volume_Average * Volume_Multiplier) conditionsMet++;
   
   return (conditionsMet >= 3);
}

//+------------------------------------------------------------------+
//| Trade Management Functions                                      |
//+------------------------------------------------------------------+
void UpdateBreakEvenSL()
{
   if(IsTrailingActive) return;
   
   double totalProfit = CalculateTotalProfit();
   double activationProfit = FirstGridDistance * Point * MarketInfo(Symbol(), MODE_TICKVALUE);
   
   if(totalProfit >= activationProfit)
   {
      CalculateBEP();
      
      double stopLevel = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
      
      for(int i = 0; i < ArraySize(TradesArray); i++)
      {
         if(OrderSelect(TradesArray[i].ticket, SELECT_BY_TICKET, MODE_TRADES))
         {
            double trailingStep = TrailingStep * Point;
            if(trailingStep < stopLevel) trailingStep = stopLevel;
            
            double newSL = (TradesArray[i].type == OP_BUY) 
                           ? BEP_Price - trailingStep 
                           : BEP_Price + trailingStep;
            
            newSL = NormalizeDouble(newSL, Digits);
            
            double currentPrice = (TradesArray[i].type == OP_BUY) ? Bid : Ask;
            if(TradesArray[i].type == OP_BUY && newSL >= currentPrice - stopLevel)
            {
               if(Debug) Print("BEP SL for BUY order #", TradesArray[i].ticket, " too close to price. SL:", newSL, " Bid:", Bid, " StopLevel:", stopLevel);
               continue;
            }
            if(TradesArray[i].type == OP_SELL && newSL <= currentPrice + stopLevel)
            {
               if(Debug) Print("BEP SL for SELL order #", TradesArray[i].ticket, " too close to price. SL:", newSL, " Ask:", Ask, " StopLevel:", stopLevel);
               continue;
            }
            
            if((TradesArray[i].type == OP_BUY && newSL > TradesArray[i].stopLoss && newSL != TradesArray[i].stopLoss) ||
               (TradesArray[i].type == OP_SELL && (newSL < TradesArray[i].stopLoss || TradesArray[i].stopLoss == 0) && newSL != TradesArray[i].stopLoss))
            {
               if(!OrderModify(TradesArray[i].ticket, TradesArray[i].openPrice, newSL, TradesArray[i].takeProfit, 0, clrNONE))
               {
                  LastError = GetLastError();
                  if(Debug) Print("BEP OrderModify failed for order #", TradesArray[i].ticket, " Error:", LastError, 
                        " NewSL:", newSL, " CurrentSL:", TradesArray[i].stopLoss, " Price:", currentPrice);
               }
               else
               {
                  if(Debug) Print("BEP SL updated for order #", TradesArray[i].ticket, " NewSL:", newSL, " Comment:", TradesArray[i].comment);
                  TradesArray[i].stopLoss = newSL;
               }
            }
         }
      }
      IsTrailingActive = true;
      GlobalVariableSet("IVB_TrailingActive", 1);
      if(Debug) Print("Break-even SL activated at ", BEP_Price);
   }
}

void UpdateSmartTrailing()
{
   if(!IsTrailingActive) return;
   
   ReadOpenTrades();
   
   double stopLevel = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
   const int maxRetries = 3;
   
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      bool ticketValid = false;
      for(int j = 0; j < OrdersTotal(); j++)
      {
         if(OrderSelect(j, SELECT_BY_POS, MODE_TRADES) && OrderTicket() == TradesArray[i].ticket && OrderMagicNumber() == MagicNumber)
         {
            ticketValid = true;
            break;
         }
      }
      
      if(!ticketValid) continue;
      
      if(OrderSelect(TradesArray[i].ticket, SELECT_BY_TICKET, MODE_TRADES))
      {
         double atr = iATR(Symbol(), ATR_Trailing_TF, ATR_Trailing_Period, 1);
         double trailingStep = UseATRTrailing ? MathMax(atr * ATRTrailingMultiplier, 20 * Point) : TrailingStep * Point;
         double trailingTPStep = TrailingTPStep * Point;
         if(trailingStep < stopLevel) trailingStep = stopLevel;
         if(trailingTPStep < stopLevel && UseTrailingTP) trailingTPStep = stopLevel;
         
         double newSL = TradesArray[i].stopLoss;
         double newTP = TradesArray[i].takeProfit;
         double currentPrice = (TradesArray[i].type == OP_BUY) ? Bid : Ask;
         double pipProfit = (currentPrice - TradesArray[i].openPrice) / Point * (TradesArray[i].type == OP_BUY ? 1 : -1);
         double minTPThreshold = TakeProfit * 1.5;
         
         if(TradesArray[i].type == OP_BUY)
         {
            if(TradesArray[i].stopLoss == 0 || TradesArray[i].stopLoss < BEP_Price)
               newSL = BEP_Price + trailingStep;
            else
               newSL = TradesArray[i].stopLoss;
            
            if(pipProfit >= MinProfitForTrailing && Bid >= newSL + trailingStep)
               newSL = Bid - trailingStep;
            
            if(UseTrailingTP && pipProfit >= minTPThreshold && TradesArray[i].takeProfit > 0 && Bid <= TradesArray[i].takeProfit - trailingTPStep)
               newTP = Bid - trailingTPStep;
            else if(!UseTrailingTP && TradesArray[i].takeProfit <= 0)
               newTP = TradesArray[i].openPrice + TakeProfit * Point;
            
            newSL = NormalizeDouble(newSL, Digits);
            newTP = NormalizeDouble(newTP, Digits);
            if(newSL >= Bid - stopLevel) continue;
            if(newTP <= Bid + stopLevel && newTP > 0) continue;
            
            bool slChanged = (newSL > TradesArray[i].stopLoss && newSL != TradesArray[i].stopLoss);
            bool tpChanged = (newTP < TradesArray[i].takeProfit && newTP > 0 && newTP != TradesArray[i].takeProfit);
            if(slChanged || tpChanged)
            {
               for(int attempt = 0; attempt < maxRetries; attempt++)
               {
                  if(!OrderModify(TradesArray[i].ticket, TradesArray[i].openPrice, newSL, newTP, 0, clrNONE))
                  {
                     LastError = GetLastError();
                     Print("Trailing attempt ", attempt+1, " failed for BUY #", TradesArray[i].ticket, " Error:", LastError,
                           " NewSL:", newSL, " NewTP:", newTP, " CurrentSL:", TradesArray[i].stopLoss, " CurrentTP:", TradesArray[i].takeProfit);
                     if(attempt == maxRetries - 1)
                        if(Debug) Print("Max retries reached for order #", TradesArray[i].ticket);
                  }
                  else
                  {
                     if(Debug) Print("Trailing updated for BUY #", TradesArray[i].ticket, " SL:", newSL, " TP:", newTP, " Comment:", TradesArray[i].comment);
                     TradesArray[i].stopLoss = newSL;
                     TradesArray[i].takeProfit = newTP;
                     break;
                  }
               }
            }
         }
         else if(TradesArray[i].type == OP_SELL)
         {
            if(TradesArray[i].stopLoss == 0 || TradesArray[i].stopLoss > BEP_Price)
               newSL = BEP_Price - trailingStep;
            else
               newSL = TradesArray[i].stopLoss;
            
            if(pipProfit <= -MinProfitForTrailing && Ask <= newSL - trailingStep)
               newSL = Ask + trailingStep;
            
            if(UseTrailingTP && pipProfit <= -minTPThreshold && TradesArray[i].takeProfit > 0 && Ask >= TradesArray[i].takeProfit + trailingTPStep)
               newTP = Ask + trailingTPStep;
            else if(!UseTrailingTP && TradesArray[i].takeProfit <= 0)
               newTP = TradesArray[i].openPrice - TakeProfit * Point;
            
            newSL = NormalizeDouble(newSL, Digits);
            newTP = NormalizeDouble(newTP, Digits);
            if(newSL <= Ask + stopLevel) continue;
            if(newTP >= Ask - stopLevel && newTP > 0) continue;
            
            bool slChanged = ((newSL < TradesArray[i].stopLoss || TradesArray[i].stopLoss == 0) && newSL != TradesArray[i].stopLoss);
            bool tpChanged = (newTP > TradesArray[i].takeProfit && newTP > 0 && newTP != TradesArray[i].takeProfit);
            if(slChanged || tpChanged)
            {
               for(int attempt = 0; attempt < maxRetries; attempt++)
               {
                  if(!OrderModify(TradesArray[i].ticket, TradesArray[i].openPrice, newSL, newTP, 0, clrNONE))
                  {
                     LastError = GetLastError();
                     if(Debug)
                     Print("Trailing attempt ", attempt+1, " failed for SELL #", TradesArray[i].ticket, " Error:", LastError,
                           " NewSL:", newSL, " NewTP:", newTP, " CurrentSL:", TradesArray[i].stopLoss, " CurrentTP:", TradesArray[i].takeProfit);
                     if(attempt == maxRetries - 1)
                        if(Debug) Print("Max retries reached for order #", TradesArray[i].ticket);
                  }
                  else
                  {
                     if(Debug) Print("Trailing updated for SELL #", TradesArray[i].ticket, " SL:", newSL, " TP:", newTP, " Comment:", TradesArray[i].comment);
                     TradesArray[i].stopLoss = newSL;
                     TradesArray[i].takeProfit = newTP;
                     break;
                  }
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Optimized Adaptive Trailing TP Function                          |
//+------------------------------------------------------------------+
void UpdateAdaptiveTrailingTP()
{
   if(!IsTrailingActive || !UseTrailingTP) return;
   
   double atr = iATR(Symbol(), ATR_Trailing_TF, ATR_Trailing_Period, 1);
   double dynamicTPStep = MathMax(atr * ATRTrailingMultiplier / 2.0, TrailingTPStep * Point);
   double stopLevel = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
   ROCValue roc = CalculateROC(1, ROC_Period);
   
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      if(OrderSelect(TradesArray[i].ticket, SELECT_BY_TICKET, MODE_TRADES))
      {
         double currentPrice = (TradesArray[i].type == OP_BUY) ? Bid : Ask;
         double pipProfit = (currentPrice - TradesArray[i].openPrice) / Point * (TradesArray[i].type == OP_BUY ? 1 : -1);
         double newTP = TradesArray[i].takeProfit;
         double minTPThreshold = TakeProfit * 1.2;
         
         if(TradesArray[i].type == OP_BUY)
         {
            if(pipProfit >= MinProfitForTrailing && MathAbs(roc.value) >= ROC_Threshold && Bid <= TradesArray[i].takeProfit - dynamicTPStep)
            {
               newTP = Bid - dynamicTPStep;
               if(newTP <= Bid + stopLevel) continue;
               if(newTP != TradesArray[i].takeProfit)
               {
                  if(!OrderModify(TradesArray[i].ticket, TradesArray[i].openPrice, TradesArray[i].stopLoss, newTP, 0, clrNONE))
                  {
                     if(Debug) Print("Adaptive TP modify failed for BUY #", TradesArray[i].ticket, " Error:", GetLastError());
                  }
                  else
                  {
                     if(Debug) Print("Adaptive TP updated for BUY #", TradesArray[i].ticket, " NewTP:", newTP);
                     TradesArray[i].takeProfit = newTP;
                  }
               }
            }
         }
         else if(TradesArray[i].type == OP_SELL)
         {
            if(pipProfit <= -MinProfitForTrailing && MathAbs(roc.value) >= ROC_Threshold && Ask >= TradesArray[i].takeProfit + dynamicTPStep)
            {
               newTP = Ask + dynamicTPStep;
               if(newTP >= Ask - stopLevel) continue;
               if(newTP != TradesArray[i].takeProfit)
               {
                  if(!OrderModify(TradesArray[i].ticket, TradesArray[i].openPrice, TradesArray[i].stopLoss, newTP, 0, clrNONE))
                  {
                     if(Debug) Print("Adaptive TP modify failed for SELL #", TradesArray[i].ticket, " Error:", GetLastError());
                  }
                  else
                  {
                     if(Debug) Print("Adaptive TP updated for SELL #", TradesArray[i].ticket, " NewTP:", newTP);
                     TradesArray[i].takeProfit = newTP;
                  }
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Update Dynamic TP And Partial Close                              |
//+------------------------------------------------------------------+
void UpdateDynamicTPAndPartialClose()
{
   if(!IsTrailingActive) return;
   
   ROCValue roc = CalculateROC(1, ROC_Period);
   if(MathAbs(roc.value) < MomentumROCThreshold) return;
   
   double atr = iATR(Symbol(), ATR_UpdateDynamicTPAndPartialClose_TF, ATR_UpdateDynamicTPAndPartialClose_Period, 1);
   double dynamicTPAdjustment = atr * DynamicTPMultiplier * Point;
   double stopLevel = MarketInfo(Symbol(), MODE_STOPLEVEL) * Point;
   
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      if(OrderSelect(TradesArray[i].ticket, SELECT_BY_TICKET, MODE_TRADES))
      {
         double currentPrice = (TradesArray[i].type == OP_BUY) ? Bid : Ask;
         double pipProfit = (currentPrice - TradesArray[i].openPrice) / Point * (TradesArray[i].type == OP_BUY ? 1 : -1);
         double newTP = TradesArray[i].takeProfit;
         double originalLot = TradesArray[i].lotSize;
         
         if(pipProfit >= TakeProfit && newTP > 0 && MathAbs(roc.value) >= MomentumROCThreshold)
         {
            if(TradesArray[i].type == OP_BUY)
               newTP = MathMax(newTP, TradesArray[i].openPrice + TakeProfit * Point + dynamicTPAdjustment);
            else
               newTP = MathMin(newTP, TradesArray[i].openPrice - TakeProfit * Point - dynamicTPAdjustment);
            
            newTP = NormalizeDouble(newTP, Digits);
            if((TradesArray[i].type == OP_BUY && newTP <= Bid + stopLevel) || 
               (TradesArray[i].type == OP_SELL && newTP >= Ask - stopLevel))
            {
               if(Debug) Print("Dynamic TP too close for order #", TradesArray[i].ticket, " TP:", newTP, " Price:", currentPrice);
            }
            else if(newTP != TradesArray[i].takeProfit)
            {
               if(!OrderModify(TradesArray[i].ticket, TradesArray[i].openPrice, TradesArray[i].stopLoss, newTP, 0, clrNONE))
               {
                  if(Debug) Print("Dynamic TP modify failed for order #", TradesArray[i].ticket, " Error:", GetLastError());
               }
               else
               {
                  if(Debug) Print("Dynamic TP updated for order #", TradesArray[i].ticket, " NewTP:", newTP);
                  TradesArray[i].takeProfit = newTP;
               }
            }
         }
         
         if(pipProfit >= PartialProfitLevel && originalLot > 0 && MathAbs(roc.value) >= MomentumROCThreshold)
         {
            double partialLot = originalLot * (PartialClosePercent / 100.0);
            if(partialLot >= 0.01)
            {
               if(TradesArray[i].type == OP_BUY)
               {
                  if(OrderClose(TradesArray[i].ticket, partialLot, Bid, 3, clrNONE))
                  {
                     if(Debug) Print("Partial close for BUY #", TradesArray[i].ticket, " Closed:", partialLot, " Remaining:", originalLot - partialLot);
                     TradesArray[i].lotSize -= partialLot;
                  }
                  else
                  {
                     if(Debug) Print("Partial close failed for BUY #", TradesArray[i].ticket, " Error:", GetLastError());
                  }
               }
               else
               {
                  if(OrderClose(TradesArray[i].ticket, partialLot, Ask, 3, clrNONE))
                  {
                     if(Debug) Print("Partial close for SELL #", TradesArray[i].ticket, " Closed:", partialLot, " Remaining:", originalLot - partialLot);
                     TradesArray[i].lotSize -= partialLot;
                  }
                  else
                  {
                     if(Debug) Print("Partial close failed for SELL #", TradesArray[i].ticket, " Error:", GetLastError());
                  }
               }
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Utility Functions                                               |
//+------------------------------------------------------------------+
int CountOrders(int type=-1)
{
   int count = 0;
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      if(type == -1 || TradesArray[i].type == type)
      {
         count++;
      }
   }
   return count;
}

double GetLastOrderPrice(int type)
{
   double lastPrice = 0;
   datetime lastTime = 0;
   
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      if(TradesArray[i].type == type)
      {
         if(TradesArray[i].openTime > lastTime)
         {
            lastPrice = TradesArray[i].openPrice;
            lastTime = TradesArray[i].openTime;
         }
      }
   }
   return lastPrice;
}

double CalculateTotalProfit()
{
   double profit = 0;
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      if(OrderSelect(TradesArray[i].ticket, SELECT_BY_TICKET, MODE_TRADES))
      {
         profit += OrderProfit() + OrderSwap() + OrderCommission();
      }
   }
   return profit;
}

void CalculateBEP()
{
   double totalLots = 0;
   double weightedPrice = 0;
   
   for(int i = 0; i < ArraySize(TradesArray); i++)
   {
      totalLots += TradesArray[i].lotSize;
      weightedPrice += TradesArray[i].openPrice * TradesArray[i].lotSize;
   }
   
   if(totalLots > 0)
   {
      BEP_Price = NormalizeDouble((weightedPrice / totalLots) + BufferPIP * Point, Digits);
   }
   else
   {
      BEP_Price = 0.0;
   }
}

void CloseAllTrades()
{
   for(int i = ArraySize(TradesArray) - 1; i >= 0; i--)
   {
      if(OrderSelect(TradesArray[i].ticket, SELECT_BY_TICKET, MODE_TRADES))
      {
         double price = (TradesArray[i].type == OP_BUY) ? Bid : Ask;
         if(!OrderClose(TradesArray[i].ticket, TradesArray[i].lotSize, price, 3, clrNONE))
         {
            LastError = GetLastError();
            if(Debug) Print("OrderClose failed for order #", TradesArray[i].ticket, " Comment:", TradesArray[i].comment, " Error:", LastError);
         }
      }
   }
   CurrentGridLevelBuy = 0;
   CurrentGridLevelSell = 0;
   IsTrailingActive = false;
   GlobalVariableSet("IVB_TrailingActive", 0);
   ArrayFree(TradesArray);
   if(Debug) Print("All trades closed due to risk management");
}

bool IsMaxDrawdownHit()
{
   if(AccountBalance() <= 0) return true;
   double equityDrawdown = (1.0 - AccountEquity() / AccountBalance()) * 100.0;
   return (equityDrawdown >= MaxDrawdown);
}

//+------------------------------------------------------------------+
//| Visualization Functions                                         |
//+------------------------------------------------------------------+
void InitializeVisuals()
{
   ObjectCreate(0, "Keltner_Middle", OBJ_TREND, 0, Time[0], 0, Time[0], 0);
   ObjectSetInteger(0, "Keltner_Middle", OBJPROP_COLOR, clrBlue);
   ObjectSetInteger(0, "Keltner_Middle", OBJPROP_WIDTH, 3);
   
   ObjectCreate(0, "Keltner_Upper", OBJ_TREND, 0, Time[0], 0, Time[0], 0);
   ObjectSetInteger(0, "Keltner_Upper", OBJPROP_COLOR, clrBlue);
   ObjectSetInteger(0, "Keltner_Upper", OBJPROP_STYLE, STYLE_DOT);
   ObjectSetInteger(0, "Keltner_Upper", OBJPROP_WIDTH, 3);
   
   ObjectCreate(0, "Keltner_Lower", OBJ_TREND, 0, Time[0], 0, Time[0], 0);
   ObjectSetInteger(0, "Keltner_Lower", OBJPROP_COLOR, clrBlue);
   ObjectSetInteger(0, "Keltner_Lower", OBJPROP_STYLE, STYLE_DOT);
   ObjectSetInteger(0, "Keltner_Lower", OBJPROP_WIDTH, 3);
}

void UpdateIndicators()
{
   KeltnerValues keltner = CalculateKeltner(1, Keltner_EMA_Period, Keltner_ATR_Multiplier, ATR_Keltner_Period);
   ObjectMove(0, "Keltner_Middle", 0, Time[1], keltner.middle);
   ObjectMove(0, "Keltner_Middle", 1, Time[0], keltner.middle);
   ObjectMove(0, "Keltner_Upper", 0, Time[1], keltner.upper);
   ObjectMove(0, "Keltner_Upper", 1, Time[0], keltner.upper);
   ObjectMove(0, "Keltner_Lower", 0, Time[1], keltner.lower);
   ObjectMove(0, "Keltner_Lower", 1, Time[0], keltner.lower);
}

bool IsRangingMarket()
{
   if(Bars < MinBarRangingMarket)
   {
      if(Debug) Print("Insufficient bars for SMA", smaRangingMarketPeriod,": ", Bars);
      return false;
   }
   double smaRangingMarket = iMA(Symbol(), smaRangingMarketTF, smaRangingMarketPeriod, 0, MODE_SMA, PRICE_CLOSE, 0);
   double price = Close[0];
   double atr = iATR(Symbol(), ATRRangingMarketTF, ATRRangingMarketPeriod, 0);
   double deviation = MathAbs(price - smaRangingMarket) / smaRangingMarket;
   
   if(UseADXFilter)
   {
      double adx = iADX(Symbol(), ADXFilterTF, ADX_Period, PRICE_CLOSE, MODE_MAIN, 1);
      if(adx > ADX_Threshold)
      {
         if(Debug) Print("Market trending detected. ADX: ", adx, " > ", ADX_Threshold);
         return false;
      }
   }
   
   return deviation < RangingThreshold && atr < MaxATR;
}

//+------------------------------------------------------------------+
//| License Restriction Functions                                   |
//+------------------------------------------------------------------+
template<typename T> int array_contains(const T& arr[], T what){
   int i=ArraySize(arr); while(--i >= 0) if(arr[i] == what) break;
   return i;
}

bool boolRestrictOnInit()
{
   boolRestrictions =
      boolRestrictExpiration     ||
      boolRestrictAccountNumber  ||
      boolRestrictAccountName    ||
      boolRestrictAccountServer  ||
      boolRestrictAccountCompany ||
      boolRestrictDemoAccount    ||
      boolRestrictSymbols;
   if(boolRestrictions)
   {
      boolRestrictionsUnverified = true;
      if((bool) TerminalInfoInteger(TERMINAL_CONNECTED))
      {
         long longAccountNumber = AccountInfoInteger(ACCOUNT_LOGIN);
         if(longAccountNumber > 0)
         {
            if(boolRestrictAccountNumber)
            {
               bool IsAccountNumberAllowed = array_contains(ListlongRestrictAccountNumber, longAccountNumber) >= 0;
               if(!IsAccountNumberAllowed)
               { return(boolRestrictAlert()); }
            }
            if(boolRestrictAccountName)
            {
               bool IsAccountNameAllowed = array_contains(ListstrRestrictAccountName, AccountInfoString(ACCOUNT_NAME)) >= 0;
               if(!IsAccountNameAllowed)
               { return(boolRestrictAlert()); }
            }
            if(boolRestrictAccountServer)
            {
               if(AccountInfoString(ACCOUNT_SERVER)      != strRestrictAccountServer)
               { return(boolRestrictAlert()); }
            }
            if(boolRestrictAccountCompany)
            {
               if(AccountInfoString(ACCOUNT_COMPANY)     != strRestrictAccountCompany)
               { return(boolRestrictAlert()); }
            }
            if(boolRestrictDemoAccount)
            {
               if(AccountInfoInteger(ACCOUNT_TRADE_MODE) != ACCOUNT_TRADE_MODE_DEMO)
               { return(boolRestrictAlert()); }
            }
            if(boolRestrictSymbols())
            { return(boolRestrictAlert()); }
            boolRestrictionsUnverified = false;
         }
      }
   }
   return(false);
}

bool boolRestrictSymbols()
{
   if(boolRestrictSymbols)
   {
      int intSymbolCount = ArraySize(strRestrictSymbols);
      if(intSymbolCount == 0) return(false);
      for(int i = 0; i < intSymbolCount; i++)
      {
         if(StringFind(_Symbol, strRestrictSymbols[i]) != WRONG_VALUE) return(false);
         int
            intLen  = StringLen(strRestrictSymbols[i]),
            intHalf = intLen / 2;
         string
            strLeft  = StringSubstr(strRestrictSymbols[i], 0, intHalf),
            strRight = StringSubstr(strRestrictSymbols[i], intHalf, intLen - intHalf);
         if((StringFind(_Symbol, strLeft)  != WRONG_VALUE) &&
            (StringFind(_Symbol, strRight) != WRONG_VALUE))
            return(false);
      }
      return(true);
   }
   return(false);
}

bool boolRestrictOnTick()
{
   if(boolRestrictions)
   {
      if(boolRestrictionsUnverified)
         return(boolRestrictOnInit());
      if(boolRestrictExpiration && (TimeCurrent() >= dtRestrictExpiration))
         return(boolRestrictAlert());
   }
   return(false);
}

bool boolRestrictAlert()
{
   if(boolRestrictAlert)
      MessageBox(strRestrictAlertMessage, strRestrictAlertCaption, MB_ICONERROR);
      ExpertRemove();
   return(true);
}

//+------------------------------------------------------------------+
//| Variables for Handling of Licensing Restrictions                 |
//+------------------------------------------------------------------+
bool
boolRestrictExpiration     = false, // Set to true, to use an Experation Date
boolRestrictAccountNumber  = false, // Set to true for Restricting by Account Number
boolRestrictAccountName    = false, // Set to true for Restricting by Account Name
boolRestrictAccountServer  = false, // Set to true for Restricting by Account Server
boolRestrictAccountCompany = false, // Set to true for Restricting by Account Company
boolRestrictDemoAccount    = false, // Set to true, to only allow Demo Accounts 
boolRestrictSymbols        = false, // Set to true, to only allow certain Symbols Wishmeluck23
boolRestrictAlert          = true,  // Display Alert Message when Restrictions apply. DO NOT CHANGE. For internal use only!
boolRestrictionsUnverified = false, // DO NOT CHANGE. For internal use only!
boolRestrictions           = false; // DO NOT CHANGE. For internal use only!

datetime 
dtRestrictExpiration       = D'2025.12.30'; // Restricted by Expration Date YYYY.MM.DD

long 
ListlongRestrictAccountNumber[] = {16384,//demo or offline acct
                                   32273017,16254766,141100660,220759630,53178495,52224637,117100933,87181205,43188284,39198211,117096691,16251762,320012,6799121,24180547,320065,87181396
                                  };

string
ListstrRestrictAccountName[]     = {"CODEGO EMIRATES L.L.C-FZ", "Rafael Solomon","RAFAEL SOLOMON","INNOCENT DIMHAIRO","Innocent Dimhairo",
                                   "Ahmad Aan Isnaini Shofwan"};  // Restricted by Account Name (Case Sensitive)

string
strRestrictAccountServer   = "XMGlobal-Demo",  // Restricted by Account Server
strRestrictAccountCompany  = "Company Name", // Restricted by Account Company
strRestrictSymbols[]       = { "EURUSD", "GBPJPY", "NZDCAD" }, // Restricted Symbols
strRestrictAlertCaption    = "Restrictions", // Alert Message Box Caption
strRestrictAlertMessage    =
   "Account Without License."+"\n"+"Your Server: "+AccountServer()+"\n"+"Your Account: "+(string)AccountNumber()+"\n"
   + "Your Account Name: " + AccountName() +"\n"+"More info: aan.isnaini@gmail.com "+"\n"+ "OR reach me on Telegram. My ID: @AanIsnaini";

void SetupChart()
  {
   ChartBackColorSet(clrBlack);
   ChartModeSet(1);
   ChartShiftSet(true);
   ChartAutoscrollSet(true);
   ChartShowGridSet(false);
   ChartUpColorSet(clrLime);
   ChartDownColorSet(clrRed);
   ChartLineColorSet(clrBlue);
   ChartBullColorSet(clrLime);
   ChartBearColorSet(clrRed);
   ChartScaleSet(4);
   return;
  }
  //+------------------------------------------------------------------+
//| The function sets chart background color.                        |
//+------------------------------------------------------------------+
bool ChartBackColorSet(const color clrs,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set the chart background color
   if(!ChartSetInteger(chart_ID,CHART_COLOR_BACKGROUND,clrs))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//| The function enables/disables the chart grid.                    |
//+------------------------------------------------------------------+
bool ChartShowGridSet(const bool value,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set the property value
   if(!ChartSetInteger(chart_ID,CHART_SHOW_GRID,0,value))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartModeSet(const long value,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set property value
   if(!ChartSetInteger(chart_ID,CHART_MODE,value))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartShiftSet(const bool value,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set property value
   if(!ChartSetInteger(chart_ID,CHART_SHIFT,0,value))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartAutoscrollSet(const bool value,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set property value
   if(!ChartSetInteger(chart_ID,CHART_AUTOSCROLL,0,value))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartUpColorSet(const color clrs,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set the color of up bar, its shadow and border of body of a bullish candlestick
   if(!ChartSetInteger(chart_ID,CHART_COLOR_CHART_UP,clrs))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartDownColorSet(const color clrs,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set the color of down bar, its shadow and border of bearish candlestick's body
   if(!ChartSetInteger(chart_ID,CHART_COLOR_CHART_DOWN,clrs))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartLineColorSet(const color clrs,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set color of the chart line and Doji candlesticks
   if(!ChartSetInteger(chart_ID,CHART_COLOR_CHART_LINE,clrs))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartBullColorSet(const color clrs,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set the color of bullish candlestick's body
   if(!ChartSetInteger(chart_ID,CHART_COLOR_CANDLE_BULL,clrs))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ChartBearColorSet(const color clrs,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set the color of bearish candlestick's body
   if(!ChartSetInteger(chart_ID,CHART_COLOR_CANDLE_BEAR,clrs))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
//+------------------------------------------------------------------+
//| Set chart scale (from 0 to 5).                                   |
//+------------------------------------------------------------------+
bool ChartScaleSet(const long value,const long chart_ID=0)
  {
//--- reset the error value
   ResetLastError();
//--- set property value
   if(!ChartSetInteger(chart_ID,CHART_SCALE,0,value))
     {
      //--- display the error message in Experts journal
      Print(__FUNCTION__+", Error Code = ",GetLastError());
      return(false);
     }
//--- successful execution
   return(true);
  }
  //+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void CreateButtons()
  {
   int Button_Height = (int)(Font_Size*2.8);
   if(!ButtonCreate(0, "Open_BuyLimit_btn", 0, 002 + 000 + Move_X, 020 + 005 + Move_Y, Button_Width + 000, Button_Height, Corner, "OPEN BUY Limit", Font_Type, Font_Size, Font_Color, clrMediumBlue, clrYellow))
      return;
   if(!ButtonCreate(0, "Open_SellLimit_btn", 0, 002 + 000 + Move_X, 020 + 0035 + Move_Y, Button_Width + 000, Button_Height, Corner, "OPEN SELL Limit", Font_Type, Font_Size, Font_Color, clrDeepPink, clrYellow))
      return;
   if(!ButtonCreate(0, "Open_Buy_btn", 0, 002 + 000 + Move_X, 020 + 075  + Move_Y, Button_Width + 000, Button_Height, Corner, "OPEN BUY", Font_Type, Font_Size, Font_Color, clrBlue, clrYellow))
      return;
   if(!ButtonCreate(0, "Open_Sell_btn", 0, 002 + 000 + Move_X, 020 + 0110  + Move_Y, Button_Width + 000, Button_Height, Corner, "OPEN SELL", Font_Type, Font_Size, Font_Color, clrRed, clrYellow))
      return;
   if(!ButtonCreate(0, "Open_BuyStop_btn", 0, 002 + 000 + Move_X, 020 + 0150 + Move_Y, Button_Width + 000, Button_Height, Corner, "OPEN BUY Stop", Font_Type, Font_Size, Font_Color, clrNavy, clrYellow))
      return;
   if(!ButtonCreate(0, "Open_SellStop_btn", 0, 002 + 000 + Move_X, 020 + 0180 + Move_Y, Button_Width + 000, Button_Height, Corner, "OPEN SELL Stop", Font_Type, Font_Size, Font_Color, clrCrimson, clrYellow))
      return;
   if(!ButtonCreate(0, "CloseALL_btn", 0, 002 + 280 + Move_X, 020 + 005 + Move_Y, Button_Width + 035, Button_Height, Corner, "Close All by MN", Font_Type, Font_Size, Font_Color, clrTeal, clrYellow))
      return;
   if(!ButtonCreate(0, "CloseALL_Buy_btn", 0, 002 + 280 + Move_X, 020 + 0035 + Move_Y, Button_Width + 035, Button_Height, Corner, "Close Buy_All by MN", Font_Type, Font_Size, Font_Color, clrTeal, clrYellow))
      return;
   if(!ButtonCreate(0, "CloseALL_Sell_btn", 0, 002 + 280 + Move_X, 020 + 0065 + Move_Y, Button_Width + 035, Button_Height, Corner, "Close Sell_All by MN", Font_Type, Font_Size, Font_Color, clrTeal, clrYellow))
      return;
   if(!ButtonCreate(0, "CloseALL_Loss_btn", 0, 002 + 280 + Move_X, 020 + 0095 + Move_Y, Button_Width + 035, Button_Height, Corner, "Close LOSS_All by MN", Font_Type, Font_Size, Font_Color, clrRed, clrYellow))
      return;
   if(!ButtonCreate(0, "CloseALL_Profit_btn", 0, 002 + 280 + Move_X, 020 + 0125 + Move_Y, Button_Width + 035, Button_Height, Corner, "Close PROFIT_All by MN", Font_Type, Font_Size, Font_Color, clrBlue, clrYellow))
      return;
      //
      // if(!ButtonCreate(0, "CloseALL_Symbol_btn2", 0, 002 + 445 + Move_X, 020 + 0155 + Move_Y, Button_Width + 080, Button_Height + 020, Corner, "Close All by SYMBOL", Font_Type, Font_Size, clrRed, clrGreen, clrYellow))
       if(!ButtonCreate(0, "CloseALL_Symbol_btn", 0, 002 + 445 + Move_X, 020 + 0155 + Move_Y, Button_Width + 030, Button_Height + 020, Corner, "Close All by SYMBOL", Font_Type, Font_Size, clrLime, clrDarkBlue, clrRed))
      return;
      //
   if(!ButtonCreate(0, "Delete___btn", 0, 002 + 450 + Move_X, 020 + 005 + Move_Y, Button_Width + 020, Button_Height, Corner, "Delete All by MN",Font_Type, Font_Size, Font_Color, clrTeal, clrYellow))
      return;
   if(!ButtonCreate(0, "Delete_PS__btn", 0, 002 + 450 + Move_X, 020 + 035 + Move_Y, Button_Width + 020, Button_Height, Corner, "Delete Stop All by MN",Font_Type, Font_Size, Font_Color, clrTeal, clrYellow))
      return;
   if(!ButtonCreate(0, "Delete_PL__btn", 0, 002 + 450 + Move_X, 020 + 065 + Move_Y, Button_Width + 020, Button_Height, Corner, "Delete Limit All by MN",Font_Type, Font_Size, Font_Color, clrTeal, clrYellow))
      return;
  
   if(!ButtonCreate(0, "ChangeBE_btn", 0, 002 + 600 + Move_X, 020 + 005 + Move_Y, Button_Width + 000, Button_Height, Corner, "SL = BE",Font_Type, Font_Size, Font_Color, clrCrimson, clrYellow))
      return;
   if(!ButtonCreate(0, "SLplusOnebtn", 0, 002 + 600 + Move_X, 020 + 035 + Move_Y, Button_Width + 000, Button_Height, Corner, "SL + 1",Font_Type, Font_Size, Font_Color, clrCrimson, clrYellow))
      return;
      
    if(!ButtonCreate(0, "SLplusTenbtn", 0, 002 + 600 + Move_X, 020 + 065 + Move_Y, Button_Width + 000, Button_Height, Corner, "SL + 10",Font_Type, Font_Size, Font_Color, clrCrimson, clrYellow))
      return;
      
   if(!ButtonCreate(0, "SLplusHundredbtn", 0, 002 + 600 + Move_X, 020 + 095 + Move_Y, Button_Width + 000, Button_Height, Corner, "SL + 100",Font_Type, Font_Size, Font_Color, clrCrimson, clrYellow))
      return;
   if(!ButtonCreate(0, "DeleteSL_btn", 0, 002 + 600 + Move_X, 020 + 125 + Move_Y, Button_Width + 000, Button_Height, Corner, "Delete SL",Font_Type, Font_Size, Font_Color, clrBlue, clrYellow))
      return;
   
   if(!ButtonCreate(0, "ChangeSL_btn", 0, 002 + 730 + Move_X, 020 + 035 + Move_Y, Button_Width + 020, Button_Height, Corner, "Change SL >>",Font_Type, Font_Size, Font_Color, clrDeepPink, clrYellow))
      return;
   if(!ButtonCreate(0, "ChangeTP_btn", 0, 002 + 730 + Move_X, 020 + 005 + Move_Y, Button_Width + 020, Button_Height, Corner, "Change TP >>",Font_Type, Font_Size, Font_Color, clrDarkGreen, clrYellow))
      return;
   ChartRedraw();
   return;
  }
  
//VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//
// This function is executed when chart event happens //
//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//
void OnChartEvent(
   const int id,         // Event ID
   const long& lparam,   // Parameter of type long event
   const double& dparam, // Parameter of type double event
   //const string& sparam,  // Parameter of type string events
   const string& action
)
//void OnChartEvent (const int id, const long &lparam, const double &dparam, const string &action)
  {
//-- write parameter to the system global variables
// here
   ResetLastError();
   int retVal = 0;
   if(id == CHARTEVENT_OBJECT_CLICK)
     {
      
      if(ObjectType(action) == OBJ_BUTTON)
        {
         ButtonPressed(0, action);
        }
      // }
     }
//closed of here
   return;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void ButtonPressed(const long chartID, const string action)
  {
   ObjectSetInteger(chartID, action, OBJPROP_BORDER_COLOR, clrBlack);  // button pressed
   if(action == "CloseALL_Symbol_btn")
     {
      int retVal = 0;
      retVal = MessageBox("Are you sure to Close all by SYMBOL ?", " C L O S E   A L L by SYMBOL:", MB_YESNO);
      if(retVal == IDYES)
         CloseALL_Symbol_Button(action);
     }
   if(action == "CloseALL_btn")
     {
      int retVal = 0;
      retVal = MessageBox("Are you sure to Close all ?", " C L O S E   A L L by Magic Number on This Chart:", MB_YESNO);
      if(retVal == IDYES)
         CloseAll_Button(action);
     }
   if(action == "CloseALL_Buy_btn")
     {
      int retVal = 0;
      retVal = MessageBox("Are you sure to Close all BUY ?", " C L O S E   A L L   B U Y by Magic Number on This Chart:", MB_YESNO);
      if(retVal == IDYES)
         CloseAll_Buy_Button(action);
     }
     
   if(action == "CloseALL_Sell_btn")
     {
      int retVal = 0;
      retVal = MessageBox("Are you sure to Close all SELL ?", " C L O S E   A L L   S E L L by Magic Number on This Chart:", MB_YESNO);
      if(retVal == IDYES)
         CloseAll_Sell_Button(action);
     }
   if(action == "CloseALL_Profit_btn")
     {
      int retVal = 0;
      retVal = MessageBox("Are you sure to Close all in PROFIT ?", " C L O S E   A L L   i n    P R O F I T by Magic Number on This Chart:", MB_YESNO);
      if(retVal == IDYES)
         CloseALL_Profit_Button(action);
     }
   if(action == "CloseALL_Loss_btn")
     {
      int retVal = 0;
      retVal = MessageBox("Are you sure to Close all in LOSS ?", " C L O S E   A L L   i n    L O S S by Magic Number on This Chart:", MB_YESNO);
      if(retVal == IDYES)
         CloseALL_Loss_Button(action);
     }
   if(action == "Open_Buy_btn")
      Open_Buy_Button(action);
   if(action == "Open_Sell_btn")
      Open_Sell_Button(action);
   if(action == "Open_BuyStop_btn")
      Open_BuyStop_Button(action);
   if(action == "Open_SellStop_btn")
      Open_SellStop_Button(action);
   if(action == "Open_BuyLimit_btn")
      Open_BuyLimit_Button(action);
   if(action == "Open_SellLimit_btn")
      Open_SellLimit_Button(action);
   if(action == "Delete___btn")
      Delete___Button(action);
   if(action == "Delete_PS__btn")
      Delete_PS__Button(action);
   if(action == "Delete_PL__btn")
      Delete_PL__Button(action);
   if(action == "ChangeBE_btn")
      ChangeBE_Button(action);
   if(action == "SLplusOnebtn")
      SLplus1__Button(action);
      
   if(action == "SLplusTenbtn")
      SLplusTen__Button(action);
      
   if(action == "SLplusHundredbtn")
      SLplusHundred__Button(action);
      
   if(action == "DeleteSL_btn")
      DeleteSL_Button(action);
   if(action == "ChangeSL_btn")
      ChangeSL_Button(action);
   if(action == "ChangeTP_btn")
      ChangeTP_Button(action);
   Sleep(1000);
   RefreshRates();
   ObjectSetInteger(chartID, action, OBJPROP_BORDER_COLOR, clrYellow);  // button unpressed
   ObjectSetInteger(chartID, action, OBJPROP_STATE, false);  // button unpressed
   ChartRedraw();
   return;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void DeleteButtons()
  {
   ButtonDelete(0, "CloseALL_Symbol_btn");
   ButtonDelete(0, "CloseALL_btn");
   ButtonDelete(0, "CloseALL_Buy_btn");
   ButtonDelete(0, "CloseALL_Sell_btn");
   ButtonDelete(0, "CloseALL_Profit_btn");
   ButtonDelete(0, "CloseALL_Loss_btn");
   ButtonDelete(0, "Open_Buy_btn");
   ButtonDelete(0, "Open_Sell_btn");
   ButtonDelete(0, "Open_BuyStop_btn");
   ButtonDelete(0, "Open_SellStop_btn");
   ButtonDelete(0, "Open_BuyLimit_btn");
   ButtonDelete(0, "Open_SellLimit_btn");
   ButtonDelete(0, "Delete___btn");
   ButtonDelete(0, "Delete_PS__btn");
   ButtonDelete(0, "Delete_PL__btn");
   ButtonDelete(0, "ChangeBE_btn");
   ButtonDelete(0, "SLplusOnebtn");
   ButtonDelete(0, "SLplusTenbtn");
   ButtonDelete(0, "SLplusHundredbtn");
   ButtonDelete(0, "DeleteSL_btn");
   ButtonDelete(0, "ChangeSL_btn");
   ButtonDelete(0, "ChangeTP_btn");
   return;
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void ToolTips_Text(const string action)
  {
   if(action == "CloseALL_Symbol_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Close All (The Total Should in Profit) Open Order(s) for **THIS SYMBOL**");
     }
     if(action == "CloseALL_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Close All Open Order(s) by Magic Number for **Current Chart** ONLY");
     }
   if(action == "CloseALL_Buy_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Close All BUY Order(s) by Magic Number for **Current Chart** ONLY");
     }
   if(action == "CloseALL_Sell_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Close All SELL Order(s) by Magic Number for **Current Chart** ONLY");
     }
   if(action == "Open_Buy_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Open BUY Order(s) by Magic Number for **Current Chart** ONLY");
     }
   if(action == "Open_Sell_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Open SELL Order(s) by Magic Number for **Current Chart** ONLY");
     }
   if(action == "Delete___btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Delete All Pending Order(s) by Magic Number for **Current Chart** ONLY");
     }
   if(action == "ChangeBE_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Set Stop Loss to Breakeven for ALL Open Order(s) on ** Current Chart ONLY.");
     }
   if(action == "SLplusOnebtn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Add 1 pip to current Stop Loss price for ALL Open Order(s) on ** Current Chart ONLY. Button is Working if Stop Loss Value NOT EMPTY.**");
     }
    if(action == "SLplusTenbtn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Add 10 pip to current Stop Loss price for ALL Open Order(s) on ** Current Chart ONLY. Button is Working if Stop Loss Value NOT EMPTY.**");
     }
    if(action == "SLplusHundredbtn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Add 100 pip to current Stop Loss price for ALL Open Order(s) on ** Current Chart ONLY. Button is Working if Stop Loss Value NOT EMPTY.**");
     }
       
   if(action == "DeleteSL_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Remove current Stop Loss value for ALL Open Order(s) on **Current Chart** ONLY");
     }
   if(action == "ChangeSL_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Change Stop Loss value for ALL Open Order(s) on **Current Chart** ONLY");
     }
   if(action == "ChangeTP_btn")
     {
      ObjectSetString(0, action, OBJPROP_TOOLTIP, "Change TP value for ALL Open Order(s) on **Current Chart** ONLY");
     }
     return;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CloseALL_Symbol_Button(const string action)
  {
         if(ClAllALL())
         {
            ///if(isBuySell)
           // GVSet(trade_comment +"ClAllALL",1);
            Sleep(7000);
            
           // if(Debug)Print(" --> Packages closed CloseALL_Symbol_Button!--> Highest "+ MaxDD);
            
            
         }
   return(0);
  }
int CloseAll_Button(const string action)
  {
   if(FIFO)
     {
      CList list;
      for(int i=OrdersTotal(); i>=0; i--)
         if(OrderSelect(i,SELECT_BY_POS)&&(Mode_Symbols==SYMBOLS_ALL || OrderSymbol()==_Symbol)&& (OrderMagicNumber()== MagicNumber))
            list.Add(new Order(OrderTicket(),OrderOpenTime()));
      list.Sort(1); // by time
      list.Sort(0); // then by ticket number
      for(Order *order = list.GetFirstNode(); order!=NULL; order=order.Next())
        {
         if(OrderSelect(order.ticket,SELECT_BY_TICKET))
           {
            if(OrderType()>1 && (Mode_Orders==ORDERS_ALL || Mode_Orders==ORDERS_PENDING))
              {
               if(!OrderDelete(order.ticket))
                  Print("OrderDeleteError: ");//,ErrorDescription(GetLastError()));
               continue;
              }
            else
               if(OrderType()<2 &&(Mode_Orders==ORDERS_ALL || Mode_Orders==ORDERS_POSITIONS))
                 {
                  MqlTick tick;
                  SymbolInfoTick(OrderSymbol(),tick);
                  double price = OrderType()==OP_BUY?tick.bid:tick.ask;
                  if(!OrderClose(OrderTicket(),OrderLots(),price,10))
                     Print("OrderCloseError: ");//,ErrorDescription(GetLastError()));
                  continue;
                 }
           }
         else
            Print("OrderSelectError: ");//,ErrorDescription(GetLastError()));
        }
     }//end if FIFO

   if(!FIFO)
     {
      for(int i=OrdersTotal(); i>=0; i--)
        {
         if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES))
           {
            if(OrderSymbol()==Symbol())
              {
               if(OrderMagicNumber() == MagicNumber)// || OrderMagicNumber() == MagicNumber_Buy ||  OrderMagicNumber() == MagicNumber_Sell || OrderMagicNumber() == MagicNumberController1 || OrderMagicNumber() == MagicNumberController2 )
                 {
                  if(OrderType() == 1)
                    {
                     while(!OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Ask,Digits),3, Red))
                       {Sleep(1000); RefreshRates();}
                    }
                  if(OrderType() == 0)
                    {
                     while(!OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Bid,Digits),3, Red))
                       {Sleep(1000); RefreshRates();}
                    }
                 }
              }
           }
        }
      DeleteAllPendingOrders(Errors);
     }//end if !FIFO
     
   if(Debug)Print(" Closing TRX  =====================>>>  Package closed Closedb !");
  // 
   
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CloseAll_Buy_Button(const string action)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol() &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2  ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 3, clrNONE);
            if(ticket == -1)
               Print("Error : ", GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
        }
     }
   
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CloseAll_Sell_Button(const string action)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 3, clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
        }
     }
   
   
   //
   //
   return(0);
  }
  
  int CloseAll_Buy()
  {
   int ticket=0;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol() &&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 3, clrNONE);
            if(ticket == -1)
               Print("Error : ", GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed by CloseAll_Buy()");
           }
        }
     }
   
  
   
   return(ticket);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CloseAll_Sell()
  {
   int ticket=0;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 3, clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed By CloseAll_Sell()");
           }
        }
     }
   
  
   return(ticket);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CloseAll_Buyxxx(int MagicNum)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol()&& OrderMagicNumber() == MagicNum)
           {
            ticket = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 3, clrNONE);
            if(ticket == -1)
               Print("Error : ", GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
        }
     }
   
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int CloseAll_Sellxxx(int MagicNum)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol()&& OrderMagicNumber() == MagicNum)
           {
            ticket = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 3, clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
        }
     }
     
   return(0);
  }
//+------------------------------------------------------------------+
//| Close all Profit Order Button                                                       |
//+------------------------------------------------------------------+
int CloseALL_Profit_Button(const string sparam)
  {
   for(int i = OrdersTotal()-1; i>=0; i--)
     {
      double Spread = Ask - Bid;
      int Ticket = OrderSelect(i, SELECT_BY_POS);
      bool result = false;
      if(OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber)&&
      OrderType() == OP_BUY && OrderProfit()+OrderSwap()+OrderCommission()-Spread>0)
         result = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 5, clrNONE);
      if( OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber)&&
      OrderType() == OP_SELL && OrderProfit()+OrderSwap()+OrderCommission()-Spread>0)
         result = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 5, clrNONE);
      //if (UseAlerts) PlaySound("alert.wav");
     }
     
   return(0);
  }
//+------------------------------------------------------------------+
//| Close all Closed Loss Button                                                       |
//+------------------------------------------------------------------+
int CloseALL_Loss_Button(const string sparam)
  {
   for(int i = OrdersTotal()-1; i>=0; i--)
     {
      double Spread = Ask - Bid;
      int Ticket = OrderSelect(i, SELECT_BY_POS);
      bool result = false;
      if(OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber)
      && OrderType() == OP_BUY && OrderProfit()+OrderSwap()+OrderCommission()-Spread<0)
         result = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_BID), 5, clrNONE);
      if(OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber)&&
      OrderType() == OP_SELL && OrderProfit()+OrderSwap()+OrderCommission()-Spread<0)
         result = OrderClose(OrderTicket(), OrderLots(), MarketInfo(OrderSymbol(), MODE_ASK), 5, clrNONE);
      //if (UseAlerts) PlaySound("alert.wav");
     }
      
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int Open_Buy_Button(const string action)
{  
   double Lot_Extract = StrToDouble(ObjectGetString(0, "LOT_OP_BUY", OBJPROP_TEXT, 0));
   OpenTrade2(OP_BUY,Lot_Extract);      
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int Open_Sell_Button(const string action)
{
   double Lot_Extract = StrToDouble(ObjectGetString(0, "LOT_OP_SELL", OBJPROP_TEXT, 0));
   OpenTrade2(OP_SELL,Lot_Extract);
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int Delete___Button(const string action)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUYLIMIT && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2  ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
         if(OrderType() == OP_SELLLIMIT && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2  ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
         if(OrderType() == OP_BUYSTOP && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
         if(OrderType() == OP_SELLSTOP && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber ))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
        }
     }
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int Delete_PS__Button(const string action)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUYSTOP && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
         if(OrderType() == OP_SELLSTOP && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
        }
     }
   return(0);
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int Delete_PL__Button(const string action)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int i = OrdersTotal() - 1; i >= 0; i--)
     {
      if(OrderSelect(i, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUYLIMIT && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
         if(OrderType() == OP_SELLLIMIT && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
            ticket = OrderDelete(OrderTicket(), clrNONE);
            if(ticket == -1)
               Print("Error : ",  GetLastError());
            if(ticket >   0)
               Print("Position ", OrderTicket()," closed");
           }
        }
     }
   return(0);
  }
//+------------------------------------------------------------------+
//| Pending BUY Stop Button                                                                 |
//+------------------------------------------------------------------+
int Open_BuyStop_Button(const string sparam)
  {
   double Lot_Extract = StrToDouble(ObjectGetString(0, "LOT_BUY", OBJPROP_TEXT, 0));
   double Price_Extract = StrToDouble(ObjectGetString(0, "PRICE_BUY", OBJPROP_TEXT, 0));
   int Ticket = 0;
   Ticket = OrderSend(Symbol(),OP_BUYSTOP,Lot_Extract,Price_Extract,3,0,0,trade_comment,MagicNumber,0,clrNONE);
   
   return(0);
  }

//+------------------------------------------------------------------+
//| Pending SELL Stop Button                                                                   |
//+------------------------------------------------------------------+
int Open_SellStop_Button(const string sparam)
  {
   double Lot_Extract = StrToDouble(ObjectGetString(0, "LOT_SELL", OBJPROP_TEXT, 0));
   double Price_Extract = StrToDouble(ObjectGetString(0, "PRICE_SELL", OBJPROP_TEXT, 0));
   int Ticket = 0;
   
      Ticket = OrderSend(Symbol(),OP_SELLSTOP,Lot_Extract,Price_Extract,3,0,0,trade_comment,MagicNumber,0,clrNONE);
     
   return(0);
  }

//+------------------------------------------------------------------+
//| Pending BUY Limit Button                                                                   |
//+------------------------------------------------------------------+
int Open_BuyLimit_Button(const string sparam)
  {
   double Lot_Extract = StrToDouble(ObjectGetString(0, "LOT_BUY_LIMIT", OBJPROP_TEXT, 0));
   double Price_Extract = StrToDouble(ObjectGetString(0, "PRICE_BUY_LIMIT", OBJPROP_TEXT, 0));
   int Ticket = 0;
   
      Ticket = OrderSend(Symbol(),OP_BUYLIMIT,Lot_Extract,Price_Extract,3,0,0,trade_comment,MagicNumber,0,clrNONE);
  
   return(0);
  }
//+------------------------------------------------------------------+
//| Pending SELL Limit Button                                                                  |
//+------------------------------------------------------------------+
int Open_SellLimit_Button(const string sparam)
  {
   double Lot_Extract = StrToDouble(ObjectGetString(0, "LOT_SELL_LIMIT", OBJPROP_TEXT, 0));
   double Price_Extract = StrToDouble(ObjectGetString(0, "PRICE_SELL_LIMIT", OBJPROP_TEXT, 0));
   int Ticket = OrderSend(Symbol(),OP_SELLLIMIT,Lot_Extract,Price_Extract,3,0,0,trade_comment,MagicNumber,0,clrNONE);
  
   return(0);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int ChangeBE_Button(const string action)
  {
   int result=0;
   
   double Sel_BE_Price = 0;
   double Buy_BE_Price = 0;
   double Total_Sell_Size = 0;
   double Total_Buy_Size = 0;
   Print("Masuk BE e");
   for(int k = 0; k < OrdersTotal(); k++)
     {
      if(OrderSelect(k, SELECT_BY_POS, MODE_TRADES))
        {
         if(OrderSymbol() == Symbol() &&(OrderMagicNumber()== MagicNumber))
           {
            if(OrderType() == OP_BUY)
              {
               Buy_BE_Price += OrderOpenPrice()*OrderLots();
               Total_Buy_Size += OrderLots();
              }
            if(OrderType() == OP_SELL)
              {
               Sel_BE_Price += OrderOpenPrice()*OrderLots();
               Total_Sell_Size += OrderLots();
              }
           }
        }
     }
   if(Buy_BE_Price > 0)
     {
      Buy_BE_Price /= Total_Buy_Size;
     }
   if(Sel_BE_Price > 0)
     {
      Sel_BE_Price /= Total_Sell_Size;
     }
   int ticket;
    double TempSL=0;
   if(OrdersTotal() == 0)
      return(0);
   for(int m = OrdersTotal() - 1; m >= 0; m--)
     {
      if(OrderSelect(m, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol()&& (OrderMagicNumber()==MagicNumber))
           {              
               RefreshRates();
               TempSL=Buy_BE_Price + 0/Pekali;
               if (Bid - TempSL < StopLevels * _Point) TempSL = Bid - StopLevels * _Point;
               ticket = OrderModify(OrderTicket(), 0, TempSL, OrderTakeProfit(), 0, clrNONE);
               if(ticket == -1)
               {
                  if(Debug)Print("Error : ", GetLastError());
                 result=ticket;
               }
               if(ticket >   0)
               {                  
                  result=ticket;
               }
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))
           {
               RefreshRates();
               TempSL=Sel_BE_Price - 0/Pekali;
               if (TempSL - Ask < StopLevels * _Point)TempSL = Ask + StopLevels * _Point;
               ticket = OrderModify(OrderTicket(), 0,TempSL , OrderTakeProfit(), 0, clrNONE);
               if(ticket == -1)
               {
                  if(Debug)Print("Error : ", GetLastError());
                  result=ticket;
               }
               if(ticket >   0)
               {                  
                  result=ticket;
               }
           }
        }
     }
   return(result);
  }
  //+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ButtonCreate(const long chart_ID = 0, const string bname = "Button", const int sub_window = 0, const int bx = 0, const int by = 0, const int width = 500,
                  const int height = 18, int corner = 0, const string Btext = "button", const string font = "Arial Bold",
                  const int font_size = 10, const color bclr = clrBlack, const color back_clr = C'170,170,170', const color border_clr = clrNONE,
                  const bool state = false, const bool back = false, const bool selection = false, const bool hidden = true, const long z_order = 0)
  {
   ResetLastError();
   if(!ObjectCreate(chart_ID, bname, OBJ_BUTTON, SubWindow, 0, 0))
     {
      Print(__FUNCTION__, " : failed to create the button! Error code : ", GetLastError());
      return(false);
     }
   ObjectSetInteger(chart_ID, bname, OBJPROP_XDISTANCE, bx);
   ObjectSetInteger(chart_ID, bname, OBJPROP_YDISTANCE, by);
   ObjectSetInteger(chart_ID, bname, OBJPROP_XSIZE, width);
   ObjectSetInteger(chart_ID, bname, OBJPROP_YSIZE, height);
   ObjectSetInteger(chart_ID, bname, OBJPROP_CORNER, corner);
   ObjectSetInteger(chart_ID, bname, OBJPROP_FONTSIZE, font_size);
   ObjectSetInteger(chart_ID, bname, OBJPROP_COLOR, bclr);
   ObjectSetInteger(chart_ID, bname, OBJPROP_BGCOLOR, back_clr);
   ObjectSetInteger(chart_ID, bname, OBJPROP_BORDER_COLOR, border_clr);
   ObjectSetInteger(chart_ID, bname, OBJPROP_BACK, back);
   ObjectSetInteger(chart_ID, bname, OBJPROP_STATE, state);
   ObjectSetInteger(chart_ID, bname, OBJPROP_SELECTABLE, selection);
   ObjectSetInteger(chart_ID, bname, OBJPROP_SELECTED, selection);
   ObjectSetInteger(chart_ID, bname, OBJPROP_HIDDEN, hidden);
   ObjectSetInteger(chart_ID, bname, OBJPROP_ZORDER,z_order);
   ObjectSetString(chart_ID, bname, OBJPROP_TEXT, Btext);
   ObjectSetString(chart_ID, bname, OBJPROP_FONT, font);
   return(true);
  }

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
bool ButtonDelete(const long chart_ID=0, const string bname="Button")
  {
   ResetLastError();
   if(!ObjectDelete(chart_ID,bname))
     {
      Print(__FUNCTION__, ": Failed to delete the button! Error code = ", GetLastError());
      return(false);
     }
   return(true);
  }
  
  
  bool DeleteAllPendingOrders(int& Err)
  {
   int Error = ERR_NO_ERROR;
   bool Result = true;   
   CList list;
   for(int i=OrdersTotal(); i>=0; i--)
      if(OrderSelect(i,SELECT_BY_POS)&&(Mode_Symbols==SYMBOLS_ALL || OrderSymbol()==_Symbol) 
               && (OrderMagicNumber() == MagicNumber))
         list.Add(new Order(OrderTicket(),OrderOpenTime()));
   list.Sort(1); // by time
   list.Sort(0); // then by ticket number
   for(Order *order = list.GetFirstNode(); order!=NULL; order=order.Next())
     {
      if(OrderSelect(order.ticket,SELECT_BY_TICKET))
        {
         if(OrderType()>1 && (Mode_Orders==ORDERS_ALL || Mode_Orders==ORDERS_PENDING))
           {
            if(!OrderDelete(order.ticket))
              {
               Print("OrderDeleteError: ");//,ErrorDescription(GetLastError()));
               Result = false;
               continue;
              }
            else
               Result = true;
           }
        }
      else
         Print("OrderSelectError: ");//,ErrorDescription(GetLastError()));
     }
   return(Result);
  }
  bool DeleteAllPendingOrdersALL(int& Err)
  {
   int Error = ERR_NO_ERROR;
   bool Result = true;   
   CList list;
   for(int i=OrdersTotal(); i>=0; i--)
      if(OrderSelect(i,SELECT_BY_POS)&&(Mode_Symbols==SYMBOLS_ALL || OrderSymbol()==_Symbol))
         list.Add(new Order(OrderTicket(),OrderOpenTime()));
   list.Sort(1); // by time
   list.Sort(0); // then by ticket number
   for(Order *order = list.GetFirstNode(); order!=NULL; order=order.Next())
     {
      if(OrderSelect(order.ticket,SELECT_BY_TICKET))
        {
         if(OrderType()>1 && (Mode_Orders==ORDERS_ALL || Mode_Orders==ORDERS_PENDING))
           {
            if(!OrderDelete(order.ticket))
              {
               Print("OrderDeleteError: ");//,ErrorDescription(GetLastError()));
               Result = false;
               continue;
              }
            else
               Result = true;
           }
        }
      else
         Print("OrderSelectError: ");//,ErrorDescription(GetLastError()));
     }
   return(Result);
  }
  
class Order : public CObject
  {
public:
   int               ticket;
   datetime          open_time;
                     Order(int ticket_number,datetime ticket_open_time)
     {
      ticket = ticket_number;
      open_time = ticket_open_time;
     }
   int               Compare(const CObject *node,const int mode=0)const override
     {
      Order *other = (Order*)node;
      if(mode==1)
        {
         if(this.open_time>other.open_time)
            return 1;
         if(this.open_time<other.open_time)
            return -1;
        }
      else
        {
         if(this.ticket>other.ticket)
            return 1;
         if(this.ticket<other.ticket)
            return -1;
        }
      return 0;
     }
  };
  ///// 
  double Pekali;
  double GetPengali()
  {
      //double Gigits = MarketInfo(Symbol(), MODE_DIGITS);
      double pengali = 0;
      switch(Digits)
           {
            case 0:
               pengali = 1;
               break;
            case 1:
               pengali = 10;
               break;
            case 2:
               pengali = 100;
               break;
            case 3:
               pengali = 100;
               break;
            case 4:
               pengali = 10000;
               break;
            case 5:
               pengali = 10000;
               break;
            case 6:
                pengali = 100000;
               break;
            case 7:
              pengali = 100000; 
               break;
            default:
               pengali = 1; 
           }         
      
         
     return(pengali);
  }
  double GetPengaliX()
  {
      //double Gigits = MarketInfo(Symbol(), MODE_DIGITS);
      double pengali = 0;
      switch(Digits)
           {
            case 0:
               pengali = 1;
               break;
            case 1:
               pengali = 1;
               break;
            case 2:
               pengali = 1;
               break;
            case 3:
               pengali = 10;
               break;
            case 4:
               pengali = 1000;
               break;
            case 5:
               pengali = 1000;
               break;
            case 6:
                pengali = 100000;
               break;
            case 7:
              pengali = 100000; 
               break;
            default:
               pengali = 1; 
           }         
      
         
     return(pengali);
  }
  int SLplus1__Button(const string action)
  {
   
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int m = OrdersTotal() - 1; m >= 0; m--)
     {
      if(OrderSelect(m, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol() && OrderStopLoss() != 0 &&(OrderMagicNumber()== MagicNumber ))// OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
               ticket = OrderModify(OrderTicket(), 0, OrderStopLoss() + 1/Pekali, OrderTakeProfit(), 0, clrNONE);
               if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  //success=false;
               }
               if(ticket >   0)
               {
                  
               }
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol() && OrderStopLoss() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
               ticket = OrderModify(OrderTicket(), 0, OrderStopLoss() - 1/Pekali, OrderTakeProfit(), 0, clrNONE);
               if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  //success=false;
               }
               if(ticket >   0)
               {
                  
                 // success=true;
               }
           }
        }
     }
   return(0);
  }
  int SLplusTen__Button(const string action)
  {
   
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int m = OrdersTotal() - 1; m >= 0; m--)
     {
      if(OrderSelect(m, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol() && OrderStopLoss() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2  ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
               ticket = OrderModify(OrderTicket(), 0, OrderStopLoss() + 10/Pekali, OrderTakeProfit(), 0, clrNONE);
               if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  //success=false;
               }
               if(ticket >   0)
               {
                   
                    
               }
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol() && OrderStopLoss() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2  ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
               ticket = OrderModify(OrderTicket(), 0, OrderStopLoss() - 10/Pekali, OrderTakeProfit(), 0, clrNONE);
               if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  //success=false;
               }
               if(ticket >   0)
               {
                   
               }
           }
        }
     }
   return(0);
  }
double CheckProfitALL(int itype) //-1= All,0=Buy,1=Sell;
  {
   double Profitb=0,Profits=0;
   for(int i=OrdersTotal()-1; i>=0; i--)
     {
      bool os = OrderSelect(i,SELECT_BY_POS);
      if(OrderSymbol()==Symbol())
        {
         if(OrderType()==OP_BUY)
           {
            Profitb+=OrderProfit()+OrderSwap()+OrderCommission();
           }
         if(OrderType()==OP_SELL)
           {
            Profits+=OrderProfit()+OrderSwap()+OrderCommission();
           }
        }
     }
   if(0==itype)
     {
      return(Profitb);
     }
   if(1==itype)
     {
      return(Profits);
     }
   if(-1==itype)
     {
      return(Profits+Profitb);
     }
   return(0);
  }
    
  bool ClAllALL()
{    
  double PL=CheckProfitALL(-1);  
  
  if(PL< 0)
      return false;
   if(PL >= 0)
   {
   if(FIFO)
     {
      CList list;
      for(int i=OrdersTotal(); i>=0; i--)
         if(OrderSelect(i,SELECT_BY_POS)&&(Mode_Symbols==SYMBOLS_ALL || OrderSymbol()==_Symbol)//close all
            //&&(OrderMagicNumber() == MagicNumber || OrderMagicNumber() == MagicNumber_Buy || OrderMagicNumber() == MagicNumber_Sell || OrderMagicNumber() == MagicNumberController)
           )
            list.Add(new Order(OrderTicket(),OrderOpenTime()));
      list.Sort(1); // by time
      list.Sort(0); // then by ticket number
      for(Order *order = list.GetFirstNode(); order!=NULL; order=order.Next())
        {
         if(OrderSelect(order.ticket,SELECT_BY_TICKET))
           {
            if(OrderType()>1 && (Mode_Orders==ORDERS_ALL || Mode_Orders==ORDERS_PENDING))
              {
               if(!OrderDelete(order.ticket))
                  Print("OrderDeleteError: ");//,ErrorDescription(GetLastError()));
               continue;
              }
            else
               if(OrderType()<2 &&(Mode_Orders==ORDERS_ALL || Mode_Orders==ORDERS_POSITIONS))
                 {
                  MqlTick tick;
                  SymbolInfoTick(OrderSymbol(),tick);
                  double price = OrderType()==OP_BUY?tick.bid:tick.ask;
                  if(!OrderClose(OrderTicket(),OrderLots(),price,10))
                     Print("OrderCloseError: ");//,ErrorDescription(GetLastError()));
                  continue;
                 }
           }
         else
            Print("OrderSelectError: ");//,ErrorDescription(GetLastError()));
        }
     }//end if FIFO

   if(!FIFO)
     {
      for(int i=OrdersTotal(); i>=0; i--)
        {
         if(OrderSelect(i,SELECT_BY_POS,MODE_TRADES))
           {
            if(OrderSymbol()==Symbol())
              {
               //if((OrderMagicNumber()==MagicNumber)||(OrderMagicNumber() == MagicNumber_Buy)||(OrderMagicNumber() == MagicNumber_Sell)||(OrderMagicNumber() == MagicNumberController))
               //  {
                  if(OrderType() == 1)
                    {
                     while(!OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Ask,Digits),3, Red))
                       {Sleep(1000); RefreshRates();}
                    }
                  if(OrderType() == 0)
                    {
                     while(!OrderClose(OrderTicket(), OrderLots(), NormalizeDouble(Bid,Digits),3, Red))
                       {Sleep(1000); RefreshRates();}
                    }
                 //}
              }
           }
        }
      DeleteAllPendingOrdersALL(Errors);
     }//end if !FIFO
    return true;
   }
   else return false;
   return false;
  }  
  
  int ChangeTP_Button(const string action)
  {
   
   double TP_Extract = StrToDouble(ObjectGetString(0, "TP_Edit", OBJPROP_TEXT, 0));
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int n = OrdersTotal() - 1; n >= 0; n--)
     {
      if(OrderSelect(n, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, OrderStopLoss(), TP_Extract, 0, clrNONE);
            if(ticket == -1)
               Print("Error : ");//, GetLastError());
            if(ticket >   0)
               {
                  
               } 
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, OrderStopLoss(), TP_Extract, 0, clrNONE);
            if(ticket == -1)
               Print("Error : ");//,  GetLastError());
            if(ticket >   0)
               {
                  
               } 
           }
        }
     }
   return(0);
  }
bool DeleteSL()
  {
   int ticket;
   if(OrdersTotal() == 0)
      return false;
   bool success=true;
   for(int n = OrdersTotal() - 1; n >= 0; n--)
     {
      if(OrderSelect(n, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol() && OrderTakeProfit() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, 0, OrderTakeProfit(), 0, clrNONE);
             if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  success=false;
               }
               if(ticket >   0)
               {                 
                  
               }
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol() && OrderTakeProfit() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, 0, OrderTakeProfit(), 0, clrNONE);
            if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  success=false;
               }
               if(ticket >   0)
               {
                   
               }
           }
        }
     }
   return success;
  }
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int ChangeSL_Button(const string action)
  {
   double SL_Extract = StrToDouble(ObjectGetString(0, "SL_Edit", OBJPROP_TEXT, 0));
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int n = OrdersTotal() - 1; n >= 0; n--)
     {
      if(OrderSelect(n, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
               ticket = OrderModify(OrderTicket(), 0, SL_Extract, OrderTakeProfit(), 0, clrNONE);
               if(ticket == -1)
                  Print("Error : ");//, GetLastError());
               if(ticket >   0)
               {
                  
               } 
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol()&&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, SL_Extract, OrderTakeProfit(), 0, clrNONE);
            if(ticket == -1)
               Print("Error : ");//,  GetLastError());
            if(ticket >   0)
               {
                  if(ticket >   0)
               {
                  
               } 
               } 
           }
        }
     }
   return(0);
  }
int DeleteSL_Button(const string action)
  {
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int n = OrdersTotal() - 1; n >= 0; n--)
     {
      if(OrderSelect(n, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol() && OrderStopLoss() != 0 && (OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, 0, OrderTakeProfit(), 0, clrNONE);
            if(ticket == -1)
               Print("Error : ");//, GetLastError());
            if(ticket >   0)
            {
                 
               }
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol() && OrderStopLoss() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, 0, OrderTakeProfit(), 0, clrNONE);
            if(ticket == -1)
               Print("Error : ");//,  GetLastError());
            if(ticket >   0)
            {
                  
               }
           }
        }
     }
   return(0);
  }
  int SLplusHundred__Button(const string action)
  {
  
   int ticket;
   if(OrdersTotal() == 0)
      return(0);
   for(int m = OrdersTotal() - 1; m >= 0; m--)
     {
      if(OrderSelect(m, SELECT_BY_POS, MODE_TRADES) == true)
        {
         if(OrderType() == OP_BUY && OrderSymbol() == Symbol() && OrderStopLoss() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2 ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
               ticket = OrderModify(OrderTicket(), 0, OrderStopLoss() + 100/Pekali, OrderTakeProfit(), 0, clrNONE);
               
               if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  //success=false;
               }
               if(ticket >   0)
               {
                  
               }
           }
         if(OrderType() == OP_SELL && OrderSymbol() == Symbol() && OrderStopLoss() != 0 &&(OrderMagicNumber()== MagicNumber))// || OrderMagicNumber()== MagicNumberController1 || OrderMagicNumber()== MagicNumberController2  ||OrderMagicNumber()== MagicNumber_Buy ||OrderMagicNumber()== MagicNumber_Sell))
           {
            ticket = OrderModify(OrderTicket(), 0, OrderStopLoss() - 100/Pekali, OrderTakeProfit(), 0, clrNONE);
            
            if(ticket == -1)
               {
                  if(Debug)Print("Error : ");//, GetLastError());
                  //success=false;
               }
               if(ticket >   0)
               {
                 
               }
           }
        }
     }
   return(0);
  }
  /////
  //+------------------------------------------------------------------+
bool AllCandlesFlatRange(int fromShift, int bars, double &outHigh, double &outLow)
{
   outHigh = High[fromShift];
   outLow  = Low[fromShift];
   double tolerance = Point * 2;

   for (int i = fromShift + 1; i < fromShift + bars; i++)
   {
      if (i >= Bars) return false;
      if (MathAbs(High[i] - outHigh) > tolerance || MathAbs(Low[i] - outLow) > tolerance)
         return false;
   }
   return true;
}

//+------------------------------------------------------------------+
void DrawVisuals()
{
   int shift = 1;
   double highDC = iHigh(NULL, 0, iHighest(NULL, 0, MODE_HIGH, Period_DC, shift));
   double lowDC  = iLow(NULL, 0, iLowest(NULL, 0, MODE_LOW, Period_DC, shift));
   double atr    = iATR(NULL, 0, Period_ATR, shift);

   if (atr <= 0.00001) return;  // ATR invalid, skip

   double dcRange = highDC - lowDC;
   double ratio   = dcRange / atr;

   double eqHigh, eqLow;

   if (ratio < Alert_Ratio)
   {
      datetime t1 = Time[shift + 1];
      datetime t2 = Time[shift];
      string tag = BOX_PREFIX + TimeToString(t1, TIME_MINUTES);

      ObjectDelete(tag);
      if (ObjectCreate(0, tag, OBJ_RECTANGLE, 0, t1, highDC, t2, lowDC))
      {
         ObjectSetInteger(0, tag, OBJPROP_COLOR, clrRed);
         ObjectSetInteger(0, tag, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, tag, OBJPROP_BACK, true);
         ObjectSetInteger(0, tag, OBJPROP_STYLE, STYLE_SOLID);
      }

      if (AllCandlesFlatRange(shift, 3, eqHigh, eqLow))
      {
         string tagHi = SL_PREFIX_H + TimeToString(t1, TIME_MINUTES);
         string tagLo = SL_PREFIX_L + TimeToString(t1, TIME_MINUTES);

         ObjectDelete(tagHi);
         ObjectCreate(0, tagHi, OBJ_HLINE, 0, t1, eqHigh);
         ObjectSetInteger(0, tagHi, OBJPROP_COLOR, clrAqua);
         ObjectSetInteger(0, tagHi, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, tagHi, OBJPROP_STYLE, STYLE_DOT);

         ObjectDelete(tagLo);
         ObjectCreate(0, tagLo, OBJ_HLINE, 0, t1, eqLow);
         ObjectSetInteger(0, tagLo, OBJPROP_COLOR, clrAqua);
         ObjectSetInteger(0, tagLo, OBJPROP_WIDTH, 1);
         ObjectSetInteger(0, tagLo, OBJPROP_STYLE, STYLE_DOT);
      }
   }

   // Draw Donchian Lines for MaxBars
   int start = MathMin(MaxBars, Bars - Period_DC - 1);
   for (int i = start; i >= 1; i--)
   {
      double h1 = iHigh(NULL, 0, iHighest(NULL, 0, MODE_HIGH, Period_DC, i));
      double h2 = iHigh(NULL, 0, iHighest(NULL, 0, MODE_HIGH, Period_DC, i - 1));
      double l1 = iLow(NULL, 0, iLowest(NULL, 0, MODE_LOW, Period_DC, i));
      double l2 = iLow(NULL, 0, iLowest(NULL, 0, MODE_LOW, Period_DC, i - 1));

      datetime t1 = Time[i];
      datetime t2 = Time[i - 1];

      string tagH = DCH_PREFIX_H + IntegerToString(i);
      string tagL = DCH_PREFIX_L + IntegerToString(i);

      ObjectDelete(tagH);
      ObjectCreate(0, tagH, OBJ_TREND, 0, t1, h1, t2, h2);
      ObjectSetInteger(0, tagH, OBJPROP_COLOR, clrYellow);
      ObjectSetInteger(0, tagH, OBJPROP_WIDTH, 2);
      ObjectSetInteger(0, tagH, OBJPROP_RAY_RIGHT, false);

      ObjectDelete(tagL);
      ObjectCreate(0, tagL, OBJ_TREND, 0, t1, l1, t2, l2);
      ObjectSetInteger(0, tagL, OBJPROP_COLOR, clrYellow);
      ObjectSetInteger(0, tagL, OBJPROP_WIDTH, 2);
      ObjectSetInteger(0, tagL, OBJPROP_RAY_RIGHT, false);
   }
}
//////
//+------------------------------------------------------------------+
//|           MakeLabel                                              |
//+------------------------------------------------------------------+
#resource "\\Files\\Velora.bmp";
 void MakeLogo()
  {
// {
   
   string gs = "g";
   for(int i=1; i<1; i++)
      gs = gs + "g";
   string Box = "B2";
   ObjectCreate(0,"BmpLabel",OBJ_BITMAP_LABEL,0,0,0);
   ObjectSetString(0,"BmpLabel",OBJPROP_BMPFILE,0,"::Files\\Velora.bmp");
   ObjectSet("BmpLabel", OBJPROP_CORNER, CORNER_RIGHT_UPPER);
   ObjectSetInteger(0,"BmpLabel",OBJPROP_XDISTANCE,1);   //x
   ObjectSetInteger(0,"BmpLabel",OBJPROP_YDISTANCE,1);   //y
   ObjectSetInteger(0,"BmpLabel",OBJPROP_XSIZE,200); // width
   ObjectSetInteger(0,"BmpLabel",OBJPROP_YSIZE,200); // height
   ObjectSetInteger(0,"BmpLabel",OBJPROP_HIDDEN,false);
// }
   return;
  }
void MakeLabel()
  {// 
   
   string gs = "g";
   for(int i=1; i<1; i++)
      gs = gs + "g";
   string Box = "B2";
   ObjectCreate(Box, OBJ_LABEL, 0, 0, 0, 0, 0);
   ObjectSetText(Box, gs, 375, "Webdings");
   //if(DashboardLocation==UPRight)
   //   ObjectSet(Box, OBJPROP_CORNER, CORNER_RIGHT_UPPER);
   //if(DashboardLocation==UPLeft)
   //   ObjectSet(Box, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   //if(DashboardLocation==LOWERRight)
   //   ObjectSet(Box, OBJPROP_CORNER, CORNER_RIGHT_LOWER);
   //if(DashboardLocation==LOWERLeft)
      ObjectSet(Box, OBJPROP_CORNER, CORNER_LEFT_LOWER);
   ObjectSet(Box, OBJPROP_XDISTANCE, 1);
   int    Ymove                            = 2;
   ObjectSet(Box, OBJPROP_YDISTANCE, Ymove-1);
   ObjectSet(Box, OBJPROP_COLOR, clrBlack);
   ObjectSet(Box, OBJPROP_BACK, FALSE);
   ObjectCreate(0,"BmpLabel",OBJ_BITMAP_LABEL,0,0,0);
   ObjectSetString(0,"BmpLabel",OBJPROP_BMPFILE,0,"::Files\\3LB.bmp");
   ObjectSet("BmpLabel", OBJPROP_CORNER, CORNER_RIGHT_UPPER);
   ObjectSetInteger(0,"BmpLabel",OBJPROP_XDISTANCE,1);   //x
   ObjectSetInteger(0,"BmpLabel",OBJPROP_YDISTANCE,1);   //y
   ObjectSetInteger(0,"BmpLabel",OBJPROP_XSIZE,200); // width
   ObjectSetInteger(0,"BmpLabel",OBJPROP_YSIZE,200); // height
   ObjectSetInteger(0,"BmpLabel",OBJPROP_HIDDEN,false);
// }
   return;
  }
//MMMMMMMMMMMMMMMMMMMMM
